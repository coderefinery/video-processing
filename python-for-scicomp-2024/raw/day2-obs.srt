1
00:00:00,000 --> 00:00:02,000
CodeRefinery.org

2
00:00:30,000 --> 00:00:32,060
you

3
00:01:00,000 --> 00:01:02,060
you

4
00:01:30,000 --> 00:01:32,060
you

5
00:02:00,000 --> 00:02:02,060
you

6
00:02:30,000 --> 00:02:32,060
you

7
00:03:00,000 --> 00:03:02,060
you

8
00:03:30,000 --> 00:03:32,060
you

9
00:04:00,000 --> 00:04:02,060
you

10
00:04:30,000 --> 00:04:32,060
you

11
00:05:00,000 --> 00:05:02,060
you

12
00:05:30,000 --> 00:05:32,060
you

13
00:06:00,000 --> 00:06:21,800
Test, test, hello, can anyone hear us out there?

14
00:06:21,800 --> 00:06:34,800
Let's see, I think we should be audible.

15
00:06:34,800 --> 00:06:38,800
Yes, I could hear you.

16
00:06:38,800 --> 00:06:41,800
Okay, that's good. Okay.

17
00:06:41,800 --> 00:06:43,800
Good.

18
00:06:43,800 --> 00:06:48,800
So hello everyone, welcome to day two.

19
00:06:48,800 --> 00:06:52,300
Let's scroll this down a little bit.

20
00:06:53,800 --> 00:06:56,800
So we have the notes here open as usual.

21
00:06:56,800 --> 00:06:59,800
If you're new and you're registered,

22
00:06:59,800 --> 00:07:03,800
you should have this page.

23
00:07:03,800 --> 00:07:08,800
Here there's a link to the archive.

24
00:07:09,800 --> 00:07:13,300
So basically all the questions from yesterday are put there,

25
00:07:13,300 --> 00:07:15,800
and you can keep reading them.

26
00:07:15,800 --> 00:07:23,800
And then here is the feedback from yesterday that will eventually be archived.

27
00:07:23,800 --> 00:07:32,400
If we keep scrolling down to the bottom, we get to day 2, and we have some initial stuff.

28
00:07:32,400 --> 00:07:36,060
So yeah, we've got questions.

29
00:07:36,060 --> 00:07:45,360
So the way this works is if you, if the statement, let's see, if you want to vote for a statement,

30
00:07:45,360 --> 00:07:56,720
O there, and we make this sort of live bar graph. So, yeah, what's the plan for... Actually,

31
00:07:56,720 --> 00:08:00,800
let's wait a few minutes before we talk about the plan for the day, so more people can arrive.

32
00:08:01,520 --> 00:08:09,360
Let's answer these questions ourselves, together. Here we have a lot of the day's

33
00:08:09,360 --> 00:08:14,400
instructors. So, how big is the data use with Python?

34
00:08:18,080 --> 00:08:25,840
Depends. It even depends on what you consider data. So, yeah, we have some

35
00:08:27,120 --> 00:08:35,440
large language models which are huge. I have seen and handled datasets with terabytes

36
00:08:35,440 --> 00:08:48,120
of data, but it really depends. It can also be as small as a megabyte or less, you know,

37
00:08:48,120 --> 00:08:58,280
just processing some small stuff. Yeah. Okay. Who else is here? [name], how big of data have

38
00:08:58,280 --> 00:09:11,000
you dealt with? Well, recently, I was dealing with this kind of Retriever Augmented Generation

39
00:09:11,000 --> 00:09:19,320
project for using large language models. The data was about 20 gigabytes plus or minus 10

40
00:09:19,320 --> 00:09:26,440
gigabytes, let's say, or plus 10 gigabytes. So it was like about 30 gigabytes of data.

41
00:09:26,440 --> 00:09:33,400
So, a relevant amount, let's say, if you don't want to crash your computer,

42
00:09:34,280 --> 00:09:41,800
you don't want to load it all at once. But, of course, it can be smaller as well.

43
00:09:43,720 --> 00:09:51,720
Yeah. [name], how big of data do you use, or what's the most?

44
00:09:51,720 --> 00:09:55,200
So typically it's, yeah, I will answer both.

45
00:09:56,680 --> 00:10:00,440
So my maybe most frequent use of data with Python

46
00:10:00,440 --> 00:10:01,520
is below one megabyte.

47
00:10:01,520 --> 00:10:06,520
It's often short CSV files, comma separated values.

48
00:10:07,160 --> 00:10:08,200
Sometimes it's more than,

49
00:10:08,200 --> 00:10:09,760
sometimes it can be like gigabytes,

50
00:10:09,760 --> 00:10:13,380
but I never went like beyond like 10 gigabyte.

51
00:10:14,800 --> 00:10:16,800
And about what's the most chaotic data,

52
00:10:16,800 --> 00:10:20,560
so one line I answered there is like messy data

53
00:10:20,560 --> 00:10:25,560
and messy meaning that either some sort of missing values,

54
00:10:28,680 --> 00:10:30,320
so data that needs to be cleaned,

55
00:10:31,240 --> 00:10:34,240
values that are missing or that are not ideal format

56
00:10:34,240 --> 00:10:38,700
or the date is not in, I don't know,

57
00:10:38,700 --> 00:10:40,880
year, year, year, year, month, month, day, day,

58
00:10:40,880 --> 00:10:42,160
but it's in something else

59
00:10:42,160 --> 00:10:44,520
and you need to then do something with the data.

60
00:10:44,520 --> 00:10:47,920
So that's what I was dealing with.

61
00:10:47,920 --> 00:10:49,920
How about you, [name]?

62
00:10:49,920 --> 00:11:11,920
Hmm, I mean, I guess a lot of the data I deal with is small, but occasionally, like right now I have a data directory of 15 gigabytes, no, 15 terabytes, that's social media data and it has the original data and pre-processed in different formats put into databases and

63
00:11:11,920 --> 00:11:25,800
It's all with Python, but definitely the time factor is the limiting thing here.

64
00:11:25,800 --> 00:11:31,720
And the most chaotic is, to me, is mostly things where the data formats the data is

65
00:11:31,720 --> 00:11:40,480
stored in is just completely inappropriate, like, before we went online, a model that

66
00:11:40,480 --> 00:11:44,800
was provided as a PDF, which is kind of, okay, great.

67
00:11:44,800 --> 00:11:47,560
Do I now have to type down that PDF

68
00:11:47,560 --> 00:11:49,440
or how do I process that?

69
00:11:52,000 --> 00:11:53,560
Yeah.

70
00:11:53,560 --> 00:11:57,160
One of the most chaotic datas that I've seen

71
00:11:57,160 --> 00:11:59,840
is probably my old data that I did

72
00:11:59,840 --> 00:12:01,320
when I was doing my master's.

73
00:12:01,320 --> 00:12:05,600
So, because over there, like the situation was

74
00:12:05,600 --> 00:12:08,200
that I was like constantly doing new things

75
00:12:08,200 --> 00:12:12,440
for folder to get the data. And it was constantly evolving. So

76
00:12:12,480 --> 00:12:15,600
and of course, I didn't have any versioning scheme I didn't have

77
00:12:15,680 --> 00:12:20,960
I didn't use. I didn't think about using even pandas to

78
00:12:20,960 --> 00:12:25,800
manage like, like get out like a table of what data I have with

79
00:12:25,800 --> 00:12:30,440
what versions I've done. So what you end up with is the dashes

80
00:12:30,440 --> 00:12:40,520
underscore scheme of having the different files managed. So suddenly you end up with a huge amount

81
00:12:40,520 --> 00:12:45,640
of files, huge amount of folders. Then I ended up targeting those folders up and then I have like,

82
00:12:47,560 --> 00:12:51,800
I think it was like something like 30 gigabytes of data that is like

83
00:12:52,920 --> 00:12:58,440
entire folders. So if I need to get access to a one file from one thing, I need to unpack a whole

84
00:12:58,440 --> 00:13:06,440
tar for all to get a hold of that. And I would do things differently now. If I would choose to do

85
00:13:06,440 --> 00:13:13,080
the same project again, I definitely would not do the choices I have done. But that happens when

86
00:13:13,080 --> 00:13:17,960
you're living at the moment. You're solving one thing at a time instead of looking at the bigger

87
00:13:17,960 --> 00:13:27,480
picture. Yeah. So, are we learning today all the lessons you wish you had known?

88
00:13:28,440 --> 00:13:32,440
when you started your work?

89
00:13:32,440 --> 00:13:36,440
Well, I don't think we can encapsulate all of that

90
00:13:36,440 --> 00:13:40,440
but hopefully the best practices are

91
00:13:40,440 --> 00:13:44,440
what's at the end.

92
00:13:44,440 --> 00:13:48,440
It's definitely a course that I wish I had when I started

93
00:13:48,440 --> 00:13:52,440
with Python. Just when you also mentioned Pandas, Pandas is a library

94
00:13:52,440 --> 00:13:56,440
that I also wish I had known

95
00:13:56,440 --> 00:14:06,740
And I wish, like this is something we might bring up later, but I really wish I would

96
00:14:06,740 --> 00:14:12,600
have understood that, hey, like these data management or data, like these tools, they

97
00:14:12,600 --> 00:14:18,240
can be used for things that are not like, let's say, big data, like you can keep track

98
00:14:18,240 --> 00:14:19,240
of your workflow.

99
00:14:19,240 --> 00:14:20,240
Okay.

100
00:14:20,240 --> 00:14:21,600
Like what simulations have I done?

101
00:14:21,600 --> 00:14:26,960
let's make a table out of it instead of just have a big folder with all of the

102
00:14:26,960 --> 00:14:34,880
different parameters specified there. So, to use the same tools that I would have used for

103
00:14:34,880 --> 00:14:41,760
the analysis to do the housekeeping, I definitely would have benefited from that. But I didn't,

104
00:14:41,760 --> 00:14:46,960
because I thought that, okay, these are different tools. These are not tools for management of,

105
00:14:46,960 --> 00:14:51,760
let's say, like I made this and stuff like that.

106
00:14:51,760 --> 00:14:55,920
So has everyone here had the not invented here syndrome

107
00:14:55,920 --> 00:14:57,560
when you started work?

108
00:14:57,560 --> 00:15:02,800
Which basically is, OK, existing tools don't exist.

109
00:15:02,800 --> 00:15:07,560
I'm going to recreate everything from scratch myself,

110
00:15:07,560 --> 00:15:13,240
or almost from scratch, and not using good stuff.

111
00:15:13,240 --> 00:15:17,320
Because I know I certainly had a lot of that.

112
00:15:17,320 --> 00:15:20,800
Admittedly, I still sometimes have.

113
00:15:20,800 --> 00:15:25,600
I mean, the main reason why I often

114
00:15:25,600 --> 00:15:27,920
tend to somewhat reinvent the wheel

115
00:15:27,920 --> 00:15:31,040
is because the wheel that I find online

116
00:15:31,040 --> 00:15:34,000
has exactly not the feature that I want,

117
00:15:34,000 --> 00:15:36,320
and about 20 other features.

118
00:15:36,320 --> 00:15:40,560
And when I'm taking that wheel, I

119
00:15:40,560 --> 00:15:43,000
need to essentially remodel a lot of things

120
00:15:43,000 --> 00:15:44,560
to have my feature present.

121
00:15:47,560 --> 00:15:48,720
Yeah.

122
00:15:48,720 --> 00:15:49,560
Okay.

123
00:15:51,880 --> 00:15:52,720
Fair enough.

124
00:15:52,720 --> 00:15:54,920
Also, I mean, there's something pedagogical

125
00:15:54,920 --> 00:15:57,040
about when you're starting off,

126
00:15:57,040 --> 00:16:00,700
making sure you understand it well enough to do it yourself.

127
00:16:00,700 --> 00:16:02,560
But anyway, it's 10 o'clock now.

128
00:16:02,560 --> 00:16:04,400
So maybe before we all go,

129
00:16:04,400 --> 00:16:07,840
we can give a summary of what we can expect from today.

130
00:16:09,040 --> 00:16:12,040
So the first session is working with data.

131
00:16:12,040 --> 00:16:15,120
So [name] and [name], how would you describe this?

132
00:16:16,120 --> 00:16:18,400
We will, I think, mainly give an overview

133
00:16:18,400 --> 00:16:22,600
of what are benefits of certain data formats.

134
00:16:24,440 --> 00:16:29,440
To consider when storing, loading, and working with data.

135
00:16:30,560 --> 00:16:35,560
And yeah, that's, I think, the main theme of this session.

136
00:16:39,280 --> 00:16:40,120
Okay, and then we have-

137
00:16:40,120 --> 00:16:41,500
in the second session.

138
00:16:41,500 --> 00:16:42,340
Go ahead.

139
00:16:42,340 --> 00:16:43,380
Yeah.

140
00:16:43,380 --> 00:16:46,220
So then right after we will talk about data visualization

141
00:16:47,220 --> 00:16:50,740
and we will demonstrate it using a library

142
00:16:50,740 --> 00:16:52,060
called Vega out there.

143
00:16:53,380 --> 00:16:56,060
And I will also demotivate why we do that,

144
00:16:56,060 --> 00:16:59,800
but it will nicely interface to the discussion about data,

145
00:16:59,800 --> 00:17:04,260
but also to the Pandas lesson from yesterday.

146
00:17:04,260 --> 00:17:07,020
So it will be a library that will very nicely interface

147
00:17:07,020 --> 00:17:08,580
to tabular data.

148
00:17:08,580 --> 00:17:09,580
Yeah.

149
00:17:09,580 --> 00:17:10,620
OK.

150
00:17:10,620 --> 00:17:12,700
Then is our lunch break.

151
00:17:12,700 --> 00:17:15,540
And then we have scripts.

152
00:17:15,540 --> 00:17:20,740
So [name], what's the motivation there?

153
00:17:20,740 --> 00:17:22,240
Up until that point, we are mainly

154
00:17:22,240 --> 00:17:23,740
working with Jupyter Notebooks.

155
00:17:23,740 --> 00:17:26,740
And one issue with Jupyter Notebooks

156
00:17:26,740 --> 00:17:33,020
is that they tend to be dependent on the state

157
00:17:33,020 --> 00:17:34,100
that you currently have.

158
00:17:34,100 --> 00:17:37,540
So if you rerun a Jupyter Notebook,

159
00:17:37,540 --> 00:17:40,220
they might, you might end up with a different result

160
00:17:40,220 --> 00:17:43,660
because you started somewhere else,

161
00:17:43,660 --> 00:17:46,260
or you run, in your previous time,

162
00:17:46,260 --> 00:17:51,260
you ran some cell in between that didn't think about it.

163
00:17:51,860 --> 00:17:54,060
And putting things into scripts,

164
00:17:54,060 --> 00:17:57,380
putting things more into functionalities,

165
00:17:57,380 --> 00:18:00,620
encapsulates these and allows you to run those

166
00:18:00,620 --> 00:18:03,300
in a non-interactive way, for example, on clusters,

167
00:18:03,300 --> 00:18:07,380
if you have to run this a couple of thousand times and so on.

168
00:18:07,380 --> 00:18:11,580
So, yeah, yeah, good.

169
00:18:11,580 --> 00:18:15,100
Yeah, let's go on, not take too much time.

170
00:18:15,100 --> 00:18:19,700
Okay, then profiling and Python productivity tools.

171
00:18:21,900 --> 00:18:22,740
So.

172
00:18:22,740 --> 00:18:23,560
Oh, yeah, right.

173
00:18:23,560 --> 00:18:25,780
So that will be again us, so it will be [name] and me.

174
00:18:25,780 --> 00:18:29,660
We will introduce a couple of really nice tools

175
00:18:29,660 --> 00:18:33,620
to profile Python in order to find out

176
00:18:34,540 --> 00:18:36,140
where is most memory spent,

177
00:18:36,140 --> 00:18:37,740
where is most CPU spent,

178
00:18:37,740 --> 00:18:39,460
we will have a discussion about

179
00:18:39,460 --> 00:18:41,300
when to optimize, how to optimize.

180
00:18:42,340 --> 00:18:46,020
And then also introduce a couple of tools that

181
00:18:46,020 --> 00:18:48,780
like for auto-formatting, linting,

182
00:18:48,780 --> 00:18:50,020
we will explain what that means

183
00:18:50,020 --> 00:18:54,480
and also have a short discussion about AI assisted coding.

184
00:18:57,100 --> 00:18:58,340
Yeah, okay.

185
00:18:58,340 --> 00:18:59,740
So with that being said,

186
00:18:59,740 --> 00:19:04,740
let's head to working with data with [name] and [name].

187
00:19:04,740 --> 00:19:16,180
and [name]. So, I will switch to your screen, I hope, and see you later. Bye.

188
00:19:17,940 --> 00:19:25,700
Okay, then let's start working with data. In general, we want to kind of address the

189
00:19:25,700 --> 00:19:34,260
questions how you store your data, how to clean up data and pre-processing and learning some

190
00:19:34,260 --> 00:19:38,180
drawbacks of and benefits of common data formats that are being used

191
00:19:39,220 --> 00:19:46,100
and how to most easily or most efficiently read write data in a different variety of formats.

192
00:19:47,300 --> 00:19:54,100
And I personally like this xkcd quite a lot because it somewhat encapsulates the problem

193
00:19:54,100 --> 00:20:02,420
of data scientists where but I did send you the data and it's really like yeah but that is a data

194
00:20:02,420 --> 00:20:05,500
data format that is completely unusable.

195
00:20:05,500 --> 00:20:08,140
This is a Word document containing embedded photo

196
00:20:08,140 --> 00:20:11,180
you took off your screen with a spreadsheet open.

197
00:20:12,420 --> 00:20:15,200
But that's how we normally do it.

198
00:20:15,200 --> 00:20:18,300
Doesn't your computer use these type of files?

199
00:20:18,300 --> 00:20:20,900
Maybe you need an update.

200
00:20:20,900 --> 00:20:25,740
And it just encapsulates the problem that

201
00:20:26,820 --> 00:20:31,820
in some fields or in collaboration with some parties,

202
00:20:31,820 --> 00:20:38,220
you just get data that is in a very specific format that is used by one tool that's common

203
00:20:38,220 --> 00:20:45,260
in this field but that's potentially even a proprietary format that you normally or often

204
00:20:45,260 --> 00:20:50,700
just can't really use. Then you need to find a way to actually make it usable.

205
00:20:53,100 --> 00:20:59,580
So I think first we want to kind of go a bit over what are the different things we are talking about.

206
00:20:59,580 --> 00:21:07,020
what is a data format? And here already format can kind of mean two different things. It can either

207
00:21:07,020 --> 00:21:11,900
be the data structure, so how you're storing the data in memory while you're working on it,

208
00:21:11,900 --> 00:21:19,660
or how you're storing the data on the disk. And that's two different things that are essentially

209
00:21:19,660 --> 00:21:25,180
considered as the kind of same with the same name and that often also leads to some confusion.

210
00:21:25,180 --> 00:21:33,820
and an example could be a simple data frame with various different columns.

211
00:21:35,260 --> 00:21:42,300
So you have a data set that consists of strings, timestamps, integers and floats.

212
00:21:43,820 --> 00:21:52,620
And how is this data then stored in memory? It's one potential thing that you might need

213
00:21:52,620 --> 00:21:56,020
need to consider for efficiency of operations.

214
00:21:56,020 --> 00:21:59,040
And this data frame already is structured

215
00:21:59,040 --> 00:22:04,300
in a so-called tidy data format, where tidy means that we have

216
00:22:04,300 --> 00:22:08,740
multiple columns of data that are somewhat collected

217
00:22:08,740 --> 00:22:13,140
and where each column represents a value of a specific type.

218
00:22:13,140 --> 00:22:17,220
So we can at least be sure that anything that's in this column

219
00:22:17,220 --> 00:22:20,580
is of this type.

220
00:22:20,580 --> 00:22:25,260
and that allows us to run several operations

221
00:22:25,260 --> 00:22:30,260
more efficiently because we can apply the same operation

222
00:22:30,340 --> 00:22:35,020
to all elements of one column at the same time.

223
00:22:35,020 --> 00:22:37,740
You can think of this in a sense,

224
00:22:37,740 --> 00:22:41,540
like if you have like a toolbox,

225
00:22:41,540 --> 00:22:43,540
let's say you have a toolbox

226
00:22:43,540 --> 00:22:46,340
that has lots of different screws around,

227
00:22:46,340 --> 00:22:48,220
like you put the different kinds of screws

228
00:22:48,220 --> 00:22:49,220
into different boxes.

229
00:22:49,220 --> 00:22:56,060
So you have different compartments in the whole box that you have the different kinds

230
00:22:56,060 --> 00:23:01,340
of screws around so that you know that you will always find these kinds of screws in

231
00:23:01,340 --> 00:23:02,340
one box.

232
00:23:02,340 --> 00:23:09,020
So it's basically like you have many different kinds of things, but they're all stored in

233
00:23:09,020 --> 00:23:15,020
this one big box, which is the data frame.

234
00:23:15,020 --> 00:23:18,060
And essentially, if you think about that screw box,

235
00:23:18,060 --> 00:23:21,740
if you would have some screw in the wrong box,

236
00:23:21,740 --> 00:23:22,900
that can be really annoying

237
00:23:22,900 --> 00:23:25,680
if you are just grabbing a few to do something

238
00:23:25,680 --> 00:23:28,020
and then notice, oh, this is useless,

239
00:23:28,020 --> 00:23:29,560
this was in the wrong box.

240
00:23:29,560 --> 00:23:32,220
So having this tidy data format

241
00:23:32,220 --> 00:23:35,200
allows you to work a lot more efficiently, essentially.

242
00:23:36,860 --> 00:23:40,540
And here's another example of a data structure

243
00:23:40,540 --> 00:23:43,820
that is relatively common,

244
00:23:43,820 --> 00:23:51,820
data array from NumPy and we have a two-dimensional array of numbers and that's somewhat different to

245
00:23:52,620 --> 00:24:03,100
a data frame because now we know the type of data in this array so each individual element of it

246
00:24:03,100 --> 00:24:11,980
is of a certain type and the advantage of this is that we can pretty efficiently store that data in

247
00:24:11,980 --> 00:24:20,940
memory because we know that each element has a specific type thus a specific size and if it's

248
00:24:21,500 --> 00:24:27,900
if the type actually has a certain number of bytes that it's always being stored in

249
00:24:28,460 --> 00:24:36,380
then we can even pre-allocate the whole memory for for this specific data structure and we can

250
00:24:36,380 --> 00:24:43,420
very easily jump to different places in memory because they are directly, they are clear from

251
00:24:43,420 --> 00:24:50,940
the indices. While for example in a data frame you could still have something that has a different

252
00:24:50,940 --> 00:24:58,700
size like a string. Strings are inherently of different sizes and you might need to first look

253
00:24:58,700 --> 00:25:06,300
up okay where is this string actually stored and then go to that location while in a numerical

254
00:25:06,300 --> 00:25:13,100
array, you can directly go to the position where the data is in the end, and you can also load that

255
00:25:13,100 --> 00:25:20,780
quite easily. If this sounds quite abstract to you, to bring it back to reality, if you remember

256
00:25:22,060 --> 00:25:27,740
from yesterday's sessions, when we talked about NumPy, why is NumPy so fast? It's fast because

257
00:25:27,740 --> 00:25:33,180
underneath the hood, it's C and Fortran. Underneath the hood of all the NumPy functions,

258
00:25:33,180 --> 00:25:38,860
the C and Fortran there. And same with the X-array, for example, that we also demonstrated

259
00:25:38,860 --> 00:25:45,020
yesterday, that used these kinds of blocks. So in X-array, all of the stuff was in NumPy arrays

260
00:25:45,020 --> 00:25:52,540
inside of it, where there's big blocks of these numbers. And because the numbers are all the same

261
00:25:52,540 --> 00:25:59,740
type, they pertain to the same variable. So they are related to a certain variable. It's very easy

262
00:25:59,740 --> 00:26:06,860
to calculate let's say a mean or histogram or let's say calculate like matrix products or

263
00:26:06,860 --> 00:26:13,100
something like that or dot products because those algorithms can be written now

264
00:26:13,900 --> 00:26:20,700
with C and Fortran for these like fast things. So if you have this kind of like uniform data that

265
00:26:20,700 --> 00:26:26,540
is stored as a cube it's very easy to write an algorithm in C that let's say calculates the

266
00:26:26,540 --> 00:26:31,660
mean for it. But if you have it all over the place, it's much harder and that makes it less

267
00:26:31,660 --> 00:26:40,700
efficient. So when you have this kind of like data that can be represented as this kind of like a

268
00:26:40,700 --> 00:26:47,100
cube, let's say like temperatures at different coordinate locations or whatever, then you can

269
00:26:47,100 --> 00:26:54,780
also write efficient algorithms that can calculate quantities from this data. So the data and the

270
00:26:54,780 --> 00:27:00,700
algorithms are and the calculations are like intimately interlinked and the speed of the

271
00:27:01,340 --> 00:27:04,860
like the stuff is intimately interlinked how it's stored in the memory.

272
00:27:07,500 --> 00:27:13,660
Essentially by knowing the type and knowing the structure yeah you you essentially get around

273
00:27:13,660 --> 00:27:17,900
having to having to have a look kind of lookup table where each element is stored.

274
00:27:17,900 --> 00:27:26,900
Now, the question is, can the data be saved to disk without changing the data format?

275
00:27:26,900 --> 00:27:32,860
So can we have an efficient data storage of this data?

276
00:27:32,860 --> 00:27:37,700
Because that would make it a lot more efficient to also load this data because we can essentially

277
00:27:37,700 --> 00:27:46,740
directly read this from disk into memory and we don't need to reorder and allocate different

278
00:27:46,740 --> 00:27:49,180
places in memory and so on.

279
00:27:49,180 --> 00:27:52,820
And that's where we have this data type

280
00:27:52,820 --> 00:27:57,260
versus data structure versus file format question.

281
00:27:57,260 --> 00:27:59,500
And commonly we say that the data type

282
00:27:59,500 --> 00:28:01,500
is the type of a single piece of data,

283
00:28:01,500 --> 00:28:03,540
so one integer, one float,

284
00:28:03,540 --> 00:28:07,900
the kind of atomic units

285
00:28:07,900 --> 00:28:11,940
that we have in a computer

286
00:28:11,940 --> 00:28:16,940
or the basic data types.

287
00:28:18,300 --> 00:28:20,140
Then we have a data structure

288
00:28:20,140 --> 00:28:24,640
that's, for example, an umpire array or a data frame

289
00:28:26,580 --> 00:28:31,580
where this is how it's stored logically within our program

290
00:28:33,020 --> 00:28:38,020
and where this data structure gives us

291
00:28:38,020 --> 00:28:43,020
certain options how to access it.

292
00:28:44,020 --> 00:28:47,700
And then we have the file format where this data structure

293
00:28:47,700 --> 00:28:49,600
needs to be stored to disk in some way.

294
00:28:50,820 --> 00:28:54,460
And that's essentially the question,

295
00:28:54,460 --> 00:28:57,120
how do we get this done in an efficient way?

296
00:29:00,340 --> 00:29:02,340
For example, for images,

297
00:29:02,340 --> 00:29:07,340
you have essentially an array of images

298
00:29:08,020 --> 00:29:14,420
if it's black and white, of black or white values

299
00:29:14,420 --> 00:29:15,820
for each individual pixel.

300
00:29:15,820 --> 00:29:20,100
And you can have that as a n times n array.

301
00:29:20,100 --> 00:29:22,820
If you have a multi-color picture,

302
00:29:22,820 --> 00:29:27,100
you would have multiple of those arrays, potentially.

303
00:29:27,100 --> 00:29:32,620
So what to look for in a file format?

304
00:29:32,620 --> 00:29:35,180
What do you want to use here?

305
00:29:35,180 --> 00:29:38,940
Well, you should remember the following.

306
00:29:38,940 --> 00:29:43,660
There is no file format that is good for every use case.

307
00:29:43,660 --> 00:29:46,780
So even if you have something

308
00:29:46,780 --> 00:29:48,860
that is really, really convenient,

309
00:29:48,860 --> 00:29:52,300
there will be cases where this is not the best format

310
00:29:52,300 --> 00:29:53,760
to store data in.

311
00:29:55,100 --> 00:29:57,800
However, it's also very likely that there is a good format

312
00:29:57,800 --> 00:29:59,860
already existing for your use case.

313
00:29:59,860 --> 00:30:10,960
And based on that, don't try to build a new file format just because, because then you

314
00:30:10,960 --> 00:30:17,520
end up with the situation that is described in this XKCD, where you have a couple of formats

315
00:30:17,520 --> 00:30:23,240
that are commonly used in the field, and then someone says, oh, it's ridiculous that there

316
00:30:23,240 --> 00:30:28,640
are so many, we should all use one file format, I will design the perfect file format.

317
00:30:28,640 --> 00:30:30,680
and what comes out of it is really just,

318
00:30:30,680 --> 00:30:33,440
yep, there's one more file format that is being used.

319
00:30:33,440 --> 00:30:35,800
So it gets more messy.

320
00:30:39,200 --> 00:30:41,200
Standardization is great,

321
00:30:41,200 --> 00:30:46,200
but to get a standard really accepted,

322
00:30:47,280 --> 00:30:49,680
it has to come from the community.

323
00:30:49,680 --> 00:30:54,680
And you have to have enough people saying,

324
00:30:54,680 --> 00:31:05,680
saying, yeah, okay, we will only use this in the future to slowly but surely drop other

325
00:31:05,680 --> 00:31:07,840
formats in the field.

326
00:31:07,840 --> 00:31:16,200
And that's a whole new thing of a whole new project on its own.

327
00:31:16,200 --> 00:31:21,800
So usually like these kinds of formats, they arrive as a solution to a problem.

328
00:31:21,800 --> 00:31:31,080
you have a problem and somebody notices that, hey, we cannot communicate in the internet

329
00:31:32,040 --> 00:31:37,480
effectively. We cannot send information from one place to another. And then JSON is born

330
00:31:39,400 --> 00:31:48,920
as a format for communicating message, basically sending stuff between different web endpoints and

331
00:31:48,920 --> 00:31:55,320
and this kind of like standards, they just appear because people realize that, hey,

332
00:31:57,000 --> 00:32:04,280
I cannot understand what this other service or thing is doing because we don't speak the

333
00:32:04,280 --> 00:32:11,400
same language. And that solves a problem, but then that problem might not be your problem.

334
00:32:12,600 --> 00:32:17,320
Your use case might have a different problem and that might be solved by a different thing.

335
00:32:17,320 --> 00:32:24,440
So it's always like it's impossible to have one thing that solves everything and every time

336
00:32:24,440 --> 00:32:33,560
somebody tries to do this it usually ends up in failure. And also one thing to I think remember

337
00:32:33,560 --> 00:32:43,640
here is that they essentially with all kind of communication patterns if you go to a certain

338
00:32:43,640 --> 00:32:51,800
common format you very often also lose something in the on the way that your original code was

339
00:32:51,800 --> 00:32:59,720
able to do that this format does not support. So having common standards always comes with

340
00:32:59,720 --> 00:33:07,640
compromises like so many things. So if you look for a file format what do you need to consider?

341
00:33:07,640 --> 00:33:13,960
So, I think, yeah, the most important that it is good for the data structure that you

342
00:33:13,960 --> 00:33:19,000
currently have, so that you, this, but this again also depends on the use case, whether

343
00:33:19,000 --> 00:33:25,480
this is the most important, this is very important, so in some, in some situations, reading and

344
00:33:25,480 --> 00:33:30,920
writing files can be very important, so having an efficient data structure that is easy,

345
00:33:30,920 --> 00:33:36,240
that is fast in being read and fast in being written is, can be very important, but it

346
00:33:36,240 --> 00:33:47,120
can also be completely irrelevant. That really depends on the use case. Is there a recommended

347
00:33:47,120 --> 00:33:56,080
format? So is there a de facto standard for your field of work? Then it's very likely

348
00:33:56,080 --> 00:34:04,300
that it's best using that format. Is it necessary that humans can actually look into the file

349
00:34:04,300 --> 00:34:06,180
and understand what it's doing?

350
00:34:06,180 --> 00:34:09,500
Or is it something that where you could say,

351
00:34:09,500 --> 00:34:11,660
well, no human needs to look at this.

352
00:34:11,660 --> 00:34:13,380
This can be completely binary.

353
00:34:13,380 --> 00:34:16,420
And when we talk about human read,

354
00:34:16,420 --> 00:34:17,300
like in this case,

355
00:34:17,300 --> 00:34:19,380
like nobody just goes and look at the bytes

356
00:34:19,380 --> 00:34:22,300
in the computer disk of memory.

357
00:34:22,300 --> 00:34:24,860
What we mean is that you can open it with an editor.

358
00:34:24,860 --> 00:34:27,620
Yeah, like you can open it with typical tools.

359
00:34:27,620 --> 00:34:31,900
Like you can view it with the file viewer

360
00:34:31,900 --> 00:34:33,420
and you see what's in there.

361
00:34:33,420 --> 00:34:35,500
Like it's a text, yeah, it's written,

362
00:34:35,500 --> 00:34:38,620
encoded in text basically, like [name] said.

363
00:34:38,620 --> 00:34:42,300
So human readable here means that instead of like

364
00:34:42,300 --> 00:34:45,700
being just bytes that you need like special tools to open.

365
00:34:46,980 --> 00:34:49,920
And I think the last is to me,

366
00:34:49,920 --> 00:34:51,580
one of the most important questions,

367
00:34:51,580 --> 00:34:53,740
is this something that I want to share

368
00:34:53,740 --> 00:34:55,500
where I want others to use it

369
00:34:55,500 --> 00:35:00,100
or is this just a temporary storage for preprocessing,

370
00:35:00,100 --> 00:35:03,940
processing, checkpointing, or something like that.

371
00:35:06,100 --> 00:35:09,620
So, Pandas or other libraries often support

372
00:35:09,620 --> 00:35:13,380
quite a large variety of different formats.

373
00:35:13,380 --> 00:35:15,920
Pandas supports a lot of tidy formats,

374
00:35:15,920 --> 00:35:18,460
but even some non-tidy formats,

375
00:35:18,460 --> 00:35:21,420
and I can convert it, we will be coming to that later.

376
00:35:23,100 --> 00:35:26,620
NumPy supports a couple of different formats for array data,

377
00:35:26,620 --> 00:35:30,020
but there are many other formats that can be used

378
00:35:30,020 --> 00:35:37,300
other libraries. And here's a very, very short thing of formats that are commonly used. And

379
00:35:37,300 --> 00:35:43,420
we actually, just by looking at it, I'm already seeing some things that I'm somewhat missing,

380
00:35:43,420 --> 00:35:50,620
like YAML instead of JSON, which is relatively similar. But this is just a kind of an overview

381
00:35:50,620 --> 00:36:04,220
table of what formats can be useful for what kind of data transfer. And to very quickly

382
00:36:04,220 --> 00:36:14,980
go over that, so PQL is essentially the binary dump from Python that comes with the benefit

383
00:36:14,980 --> 00:36:19,980
of it's, you can essentially dump almost anything.

384
00:36:23,340 --> 00:36:27,260
The problem with that is that wherever you load this,

385
00:36:27,260 --> 00:36:29,140
you have to have the same libraries.

386
00:36:29,140 --> 00:36:31,580
Otherwise you can end up with corrupt stuff

387
00:36:31,580 --> 00:36:33,860
because it assumes that the environment

388
00:36:33,860 --> 00:36:37,300
that it's loading it into is the same

389
00:36:37,300 --> 00:36:39,820
as the environment that created it.

390
00:36:39,820 --> 00:36:42,540
So it's a bit frickle.

391
00:36:42,540 --> 00:36:47,600
CSV, I think everyone knows comma separated value files, is

392
00:36:47,600 --> 00:36:54,240
human readable format, is a textual format, and convenient

393
00:36:54,240 --> 00:36:59,940
for a lot of data transfer or just a quick visual inspection

394
00:36:59,940 --> 00:37:00,660
by humans.

395
00:37:01,660 --> 00:37:06,820
Federer is, I can quickly say the next two, like Federer is a

396
00:37:06,820 --> 00:37:10,380
format that is designed for this like inter-process

397
00:37:10,380 --> 00:37:15,220
communication. So it's, it's, it uses this Apache arrow kind of

398
00:37:15,220 --> 00:37:19,300
like ID. So it's for tidy data, but it's meant for like, how you

399
00:37:19,300 --> 00:37:23,100
can communicate stuff from let's say, Python to R very

400
00:37:23,100 --> 00:37:28,180
effective, effectively, so that, like, you can use the same, get

401
00:37:28,180 --> 00:37:32,020
the same data, exact same data to load on a different process.

402
00:37:32,020 --> 00:37:35,260
And then you can, like, continue working on in a different

403
00:37:35,260 --> 00:37:38,740
process and then move it back around.

404
00:37:38,740 --> 00:37:43,120
Part K is a bit of a bigger format that it's

405
00:37:43,120 --> 00:37:45,740
mainly used to store a huge amount of data,

406
00:37:45,740 --> 00:37:47,300
so it's a big data format.

407
00:37:47,300 --> 00:37:51,060
It's this file format that is commonly used to store

408
00:37:51,060 --> 00:37:53,660
in big data in this columnar format,

409
00:37:53,660 --> 00:37:55,020
like a tidy data format,

410
00:37:55,020 --> 00:37:56,860
but really for big data,

411
00:37:56,860 --> 00:38:01,780
and it's highly used in world data sciences.

412
00:38:01,780 --> 00:38:12,780
And NPI is the NumPy file format, HDF5 is another binary format for, I think, also tabular data.

413
00:38:12,780 --> 00:38:22,780
No, no, HDF5 is for big arrays, but it stores, basically, it's a hierarchical file format.

414
00:38:22,780 --> 00:38:25,780
So, it basically has lots of folders inside of it.

415
00:38:25,780 --> 00:38:33,220
of it. And NetCDF uses HDF5, and we talked about that in the X-array yesterday, but it basically

416
00:38:33,860 --> 00:38:40,420
creates a certain kind of like structure inside the HDF5 that you find the same things in the

417
00:38:40,420 --> 00:38:49,540
same places, coordinates, times, and so forth. But overall, there's more in-depth description

418
00:38:49,540 --> 00:38:54,660
of all of these file formats that can be found on the page that we've linked here,

419
00:38:54,660 --> 00:39:00,900
where all of them are explained in a lot more detail and what they can and partially cannot do.

420
00:39:02,580 --> 00:39:08,500
I'll quickly add also what [name] mentioned about YAMLs, that this also applies to, let's say,

421
00:39:08,500 --> 00:39:14,740
configuration files. If you're writing a configuration file for your machine learning

422
00:39:14,740 --> 00:39:20,100
project or whatever, you want to store parameters into configuration files. We'll talk about

423
00:39:20,100 --> 00:39:26,260
configuration files more in the script section, but there people are also using standards or

424
00:39:26,260 --> 00:39:31,700
they, well, everybody has their own, but people are using different kinds of configuration files.

425
00:39:32,500 --> 00:39:38,180
Some people use XML, some use JSON, some use YAML, but anyways, they usually use

426
00:39:38,180 --> 00:39:46,180
these most common formats and some use any files as well, because you already have existing tools

427
00:39:46,180 --> 00:39:52,420
that can read these files. So it's much easier to manage like configurations for your simulations.

428
00:39:52,420 --> 00:39:58,020
So do also remember that those are also like important because they save a lot of work if you

429
00:39:58,020 --> 00:40:06,260
use already existing formats. But I think most important is that you understand a bit of

430
00:40:06,260 --> 00:40:14,020
what are the pros and cons of the two major kind of types of formats. Binary formats versus

431
00:40:14,020 --> 00:40:24,180
textual formats. Binary formats have the real benefit of, they represent for example floating

432
00:40:24,180 --> 00:40:30,820
point numbers with full precision. So you store the floating point number in a binary format,

433
00:40:30,820 --> 00:40:38,820
you don't have to convert into a textual format where there is a certain cutoff. So you are always

434
00:40:38,820 --> 00:40:45,960
rounding to a certain position or it gets really really huge. It can

435
00:40:45,960 --> 00:40:51,180
potentially by doing that save a lot of space because the storage is more

436
00:40:51,180 --> 00:40:58,820
efficient. Data reading and writing is coming a lot faster because often the

437
00:40:58,820 --> 00:41:04,060
data can be directly transferred into memory and memory allocation can be done

438
00:41:04,060 --> 00:41:07,860
a lot more efficiently because we know what kind of data is coming in and we

439
00:41:07,860 --> 00:41:12,140
you do not need to read on and see what is going to happen.

440
00:41:15,700 --> 00:41:19,620
They can provide you with a more explicit specification

441
00:41:19,620 --> 00:41:21,620
for storing multiple datasets

442
00:41:21,620 --> 00:41:23,940
and their metadata in the same file

443
00:41:23,940 --> 00:41:26,580
and making that read-write more efficient.

444
00:41:28,220 --> 00:41:32,860
I think one of the biggest benefits for binary formats,

445
00:41:32,860 --> 00:41:34,740
especially in heavy computation,

446
00:41:34,740 --> 00:41:38,200
is that they often allow you to partially load data.

447
00:41:38,200 --> 00:41:40,740
Because if you know how the data is structured,

448
00:41:40,740 --> 00:41:45,740
if you know that, okay, this is a huge array of numbers,

449
00:41:49,420 --> 00:41:53,780
you can say, okay, I want position whatever

450
00:41:53,780 --> 00:41:57,540
and up to position, up to the next one,

451
00:41:57,540 --> 00:42:00,340
and load only that block into memory.

452
00:42:00,340 --> 00:42:02,540
And I don't need to go through all of it

453
00:42:02,540 --> 00:42:04,720
to see when do I reach that point,

454
00:42:04,720 --> 00:42:08,760
but I can directly jump to that point on the disk.

455
00:42:08,760 --> 00:42:11,160
And that makes it a lot more efficient to,

456
00:42:11,160 --> 00:42:14,120
for example, also do things like memory mapping,

457
00:42:14,120 --> 00:42:17,720
where you essentially tell the operating system that,

458
00:42:17,720 --> 00:42:22,720
yeah, this file is another bit of memory,

459
00:42:22,980 --> 00:42:26,680
and it's not as efficient as memory itself,

460
00:42:26,680 --> 00:42:30,400
but reasonably efficient for getting the data

461
00:42:30,400 --> 00:42:31,900
and getting parts of the data.

462
00:42:32,540 --> 00:42:42,540
The disadvantages is that often you need some specific library to read and write the data.

463
00:42:42,540 --> 00:42:49,540
While this is handled if you have certain standard file formats,

464
00:42:49,540 --> 00:42:57,540
it can still be problematic if that file format doesn't have support in some programming language,

465
00:42:57,540 --> 00:43:00,100
and then you are somewhat stuck.

466
00:43:02,560 --> 00:43:05,980
If it's a proprietary format for a,

467
00:43:05,980 --> 00:43:08,260
or a format that is binary,

468
00:43:08,260 --> 00:43:11,020
but for a specific library

469
00:43:11,020 --> 00:43:13,420
that can be dependent on the library version.

470
00:43:13,420 --> 00:43:14,940
So it might not be,

471
00:43:14,940 --> 00:43:17,460
it might be that what you just stored

472
00:43:17,460 --> 00:43:19,740
cannot be used in two years

473
00:43:19,740 --> 00:43:23,020
or cannot be used with the latest version in two years.

474
00:43:23,020 --> 00:43:24,900
They are not human readable.

475
00:43:24,900 --> 00:43:28,380
So it's almost impossible to investigate

476
00:43:28,380 --> 00:43:34,860
what's actually in that file unless you read it in.

477
00:43:34,860 --> 00:43:39,220
Sharing can, therefore, be a bit more difficult.

478
00:43:39,220 --> 00:43:42,940
And it might require additional documentation efforts.

479
00:43:42,940 --> 00:43:46,340
But in the end, the last point is, yeah,

480
00:43:46,340 --> 00:43:51,380
you should do that anyways, even if you have a textual format.

481
00:43:51,380 --> 00:43:53,740
The advantage of textual formats is really,

482
00:43:53,740 --> 00:43:56,020
the huge advantage is it's human-readable.

483
00:43:56,020 --> 00:43:57,920
You can look at that file and understand,

484
00:43:57,920 --> 00:44:00,220
okay, this is what's in there.

485
00:44:00,220 --> 00:44:04,740
It's easy to, or relatively easy to check for errors

486
00:44:04,740 --> 00:44:07,300
in the data itself because you can look at it.

487
00:44:09,900 --> 00:44:12,140
It's either supported by many tools

488
00:44:12,140 --> 00:44:17,140
or you can easily write something to read the data in

489
00:44:18,300 --> 00:44:20,100
and it's relatively easily shared.

490
00:44:20,100 --> 00:44:26,620
Disadvantages, it's very slow or comparatively slow to read and write because you have to

491
00:44:26,620 --> 00:44:33,420
read through it and you don't know what's going to be there.

492
00:44:33,420 --> 00:44:42,400
It potentially increases disk space usage a lot if you need to use multiple bytes instead

493
00:44:42,400 --> 00:44:48,780
of one byte for certain data or represent it properly.

494
00:44:48,780 --> 00:44:55,540
As we mentioned, it's prone to losing precision for floating point numbers.

495
00:44:55,540 --> 00:45:07,020
Multidimensional data is often difficult to represent and if you have data where the data

496
00:45:07,020 --> 00:45:12,700
format can be specified, the data structure might not be clear when you start to read

497
00:45:12,700 --> 00:45:26,780
the data, so it's just potentially more difficult to use from the computational side.

498
00:45:26,780 --> 00:45:34,000
One thing that I tend to think of is really this, how am I going to use this? Is this

499
00:45:34,000 --> 00:45:42,160
something where I really start more as a checkpointing, as a temporary format, then I'm almost always

500
00:45:42,160 --> 00:45:43,440
is going to go for binary formats

501
00:45:43,440 --> 00:45:45,380
because they are more efficient.

502
00:45:45,380 --> 00:45:47,760
If this is something that is my final results,

503
00:45:49,040 --> 00:45:51,440
I am more likely to use some kind of textual format

504
00:45:52,200 --> 00:45:56,440
because it is easier for others to see or to understand it.

505
00:45:59,120 --> 00:46:04,840
I think, given the time, we will skip the exercise here.

506
00:46:04,840 --> 00:46:09,920
[name], do you want to go over this?

507
00:46:09,920 --> 00:46:11,480
Yeah, I don't know.

508
00:46:11,480 --> 00:46:16,200
Yeah, we're quite tight on time, so I don't know.

509
00:46:19,600 --> 00:46:22,720
I think Erano mentioned that we are allowed

510
00:46:22,720 --> 00:46:23,920
to go over time a little bit.

511
00:46:23,920 --> 00:46:28,880
OK, so maybe I could quickly go through an example of how

512
00:46:28,880 --> 00:46:31,280
does this happens in practice.

513
00:46:31,280 --> 00:46:34,960
This is kind of stuff that can happen in practice.

514
00:46:34,960 --> 00:46:37,520
Do you have a Jupyter open, [name]?

515
00:46:37,520 --> 00:46:38,960
No, not at the moment.

516
00:46:38,960 --> 00:46:43,960
Okay, I wonder, could I take a share

517
00:46:44,880 --> 00:46:47,640
or should I just explain what's happening here?

518
00:46:47,640 --> 00:46:48,480
Maybe.

519
00:46:48,480 --> 00:46:49,300
I think explaining in this way.

520
00:46:49,300 --> 00:46:52,160
Yeah, maybe explaining in this time, time scalers.

521
00:46:52,160 --> 00:46:54,320
So let's consider that we want to,

522
00:46:56,000 --> 00:47:00,000
like, it's a bit unfortunate we cannot view the data,

523
00:47:00,000 --> 00:47:03,600
how it looks, maybe.

524
00:47:03,600 --> 00:47:12,240
Yeah, so, well, you can try this on your own Jupyter, like running the example and viewing

525
00:47:12,240 --> 00:47:21,020
what the contrast is, and you just have to trust me, bro, on what the data looks like.

526
00:47:21,020 --> 00:47:27,200
So as an example of like, what can happen if you don't like, what sort of things can

527
00:47:27,200 --> 00:47:36,520
happen if you don't go through, you don't necessarily think about what is the data format

528
00:47:36,520 --> 00:47:40,320
and how can you convert it into the format that you want to use.

529
00:47:40,320 --> 00:47:46,840
So let's say we want data from this JSON or this API endpoint that provides information

530
00:47:46,840 --> 00:47:48,320
about countries.

531
00:47:48,320 --> 00:47:56,200
And if you run the first commands there, it will produce you a JSON file, and the JSON

532
00:47:56,200 --> 00:47:59,200
when we call the JSON loads,

533
00:47:59,200 --> 00:48:04,200
it will load it into a Python dictionary, basically.

534
00:48:04,200 --> 00:48:09,200
So it's a list of dictionaries for each country, basically.

535
00:48:09,200 --> 00:48:13,200
So each country is represented by a dictionary that has various values.

536
00:48:13,200 --> 00:48:15,200
So it's basically very deep.

537
00:48:15,200 --> 00:48:18,200
And this is very common for, let's say, JSON files,

538
00:48:18,200 --> 00:48:22,200
that you have multiple layers of deep going on.

539
00:48:22,200 --> 00:48:28,640
And if we want to ask a question from this data, okay, you got it, got one open, yeah.

540
00:48:28,640 --> 00:48:29,640
If you want to...

541
00:48:29,640 --> 00:48:30,640
I just need to...

542
00:48:30,640 --> 00:48:31,640
Oops, that's the wrong thing.

543
00:48:31,640 --> 00:48:32,640
Yeah, that helps.

544
00:48:32,640 --> 00:48:42,760
So, if you want to ask a question from this data, okay, like what country has the most

545
00:48:42,760 --> 00:48:43,760
population?

546
00:48:43,760 --> 00:48:44,760
The...

547
00:48:44,760 --> 00:48:45,760
Yeah, sorry about this.

548
00:48:45,760 --> 00:48:46,760
Sorry.

549
00:48:46,760 --> 00:48:51,760
Yeah, sorry about this.

550
00:48:51,760 --> 00:48:52,760
Sorry.

551
00:48:52,760 --> 00:48:53,760
Yeah, no.

552
00:48:53,760 --> 00:48:54,760
Yeah.

553
00:48:54,760 --> 00:49:02,760
So if we, do you want to close the sidebar on the JupyterLab?

554
00:49:02,760 --> 00:49:03,760
Yeah.

555
00:49:03,760 --> 00:49:07,760
A bit more space.

556
00:49:07,760 --> 00:49:11,760
You can press the folder on the left side.

557
00:49:11,760 --> 00:49:12,760
Yeah, right.

558
00:49:12,760 --> 00:49:14,760
Yeah.

559
00:49:14,760 --> 00:49:30,400
So, the data, if you type the country's JSON over there, we can view what is the data.

560
00:49:30,400 --> 00:49:36,320
So we have this sort of stuff, and this is, of course, not tied in any way, or it's not

561
00:49:36,320 --> 00:49:38,540
organized in columns.

562
00:49:38,540 --> 00:49:41,960
But this is something that you might see quite often.

563
00:49:41,960 --> 00:49:46,720
And what you might first think of writing, to answer a question, you might quote something

564
00:49:46,720 --> 00:49:47,720
like this.

565
00:49:47,720 --> 00:49:55,480
So this is a questionable way of solving the problem, which country has the most population.

566
00:49:55,480 --> 00:50:02,800
So basically we for loop over the whole structure, we check if the population is bigger, and

567
00:50:02,800 --> 00:50:07,620
And then we like, if it's bigger than, like, which one, like, if it's bigger than the previous

568
00:50:07,620 --> 00:50:12,160
biggest, then we, we mark it, yeah.

569
00:50:12,160 --> 00:50:19,020
And then we get, but this, like, if you run it, run the code, this will of course, like

570
00:50:19,020 --> 00:50:23,120
go through the whole data and it will throw out all of the rest of the data.

571
00:50:23,120 --> 00:50:25,080
And it will only answer this one question.

572
00:50:25,080 --> 00:50:28,320
And we had to write a lot of code to do this.

573
00:50:28,320 --> 00:50:34,640
So now our data analysis, of course, this might look very natural, but once we have to do this

574
00:50:34,640 --> 00:50:41,920
again and again, it gets super complicated quite quickly. Another option that often I see

575
00:50:43,520 --> 00:50:52,320
is that you could pick a few columns from the data and then append them to a list and then

576
00:50:52,320 --> 00:50:59,760
used at least to create the data frame. That's already like a better solution in a sense that

577
00:51:03,600 --> 00:51:09,360
you get a data frame at the end, so you get something out of it. But if you look a bit

578
00:51:09,360 --> 00:51:16,400
deeper in the documentation of pandas, there's like two functions at least. So there's this

579
00:51:16,400 --> 00:51:20,080
So if you want to run the JSON normalize one, for example,

580
00:51:20,080 --> 00:51:23,680
that basically load the whole thing in

581
00:51:23,680 --> 00:51:26,680
and make it into a tidy data set.

582
00:51:26,680 --> 00:51:29,080
So there's two options here, but the JSON normalize,

583
00:51:29,080 --> 00:51:32,800
it basically goes through the depth of the whole JSON

584
00:51:32,800 --> 00:51:35,520
and it will create you a nice data set.

585
00:51:35,520 --> 00:51:38,920
So if you want to now view the country's data frame

586
00:51:38,920 --> 00:51:40,240
and what it looks like,

587
00:51:41,640 --> 00:51:44,240
you can do that by clicking on this button here.

588
00:51:44,240 --> 00:51:53,080
Yeah, so this is a bit of a quick demo, but now we loaded everything.

589
00:51:53,080 --> 00:51:58,800
We didn't only check the population, what is the maximum population, we just got everything

590
00:51:58,800 --> 00:52:01,160
in one line of code.

591
00:52:01,160 --> 00:52:06,760
And this is the question, like again, a thing that happens quite often, like there are usually

592
00:52:06,760 --> 00:52:11,480
tools that people have written because they have encountered the same problem.

593
00:52:11,480 --> 00:52:17,360
And quite often, if you end up writing these large pieces of code that basically go through

594
00:52:17,360 --> 00:52:25,320
data and they shuffle around and they pick the relevant pieces of data from a data set,

595
00:52:25,320 --> 00:52:37,280
and then they are collected into a grab bag of stuff, basically like all you eat buffet

596
00:52:37,280 --> 00:52:43,360
and collect it into a plate, like all kinds of stuff, then what happens is that the big

597
00:52:43,360 --> 00:52:49,720
picture is lost and what the data actually represents is lost and you lose most of the

598
00:52:49,720 --> 00:52:50,720
data.

599
00:52:50,720 --> 00:52:56,680
But most of the time, there are tools that can immediately do all of this for you and

600
00:52:56,680 --> 00:53:04,960
make it into a tidy dataset or like, let's say, a NumPy array, like a big dataset that

601
00:53:04,960 --> 00:53:09,520
can then view all of the data from different angles. You can look at different checks and

602
00:53:09,520 --> 00:53:19,120
you can view the data as a whole instead of like this complicated list. So this is just a demo,

603
00:53:19,120 --> 00:53:28,080
maybe a bit scuffed one, because it's quite a new one. But now we could save this as a CSV

604
00:53:28,080 --> 00:53:33,680
or a parquet or feather or something. And now it would be in a tidy format if you want to save this

605
00:53:33,680 --> 00:53:41,680
data. So these kind of data conversions, when we take data and then we convert it into another

606
00:53:41,680 --> 00:53:50,560
structure, it's usually a good idea to stop and think for a second, what do I want to do with

607
00:53:50,560 --> 00:53:56,960
this data and what format would best represent the data? Is it best represented by the JSON

608
00:53:56,960 --> 00:54:01,840
format or is it best represented as a table? Because the same data is in both formats.

609
00:54:01,840 --> 00:54:07,200
It's just a question of, okay, did I convert it into another one?

610
00:54:07,200 --> 00:54:11,320
And usually there are tools to do this conversion for you.

611
00:54:11,320 --> 00:54:17,560
So I think as an overall thing to remember from this lecture, there is no file format

612
00:54:17,560 --> 00:54:20,320
that is good for every use case.

613
00:54:20,320 --> 00:54:28,000
Depending on your use case, it really depends what kind of file format you want to use.

614
00:54:28,000 --> 00:54:34,000
Basically your research question determines what libraries you use and therefore also

615
00:54:34,000 --> 00:54:40,320
to some extent what formats you're going to use.

616
00:54:40,320 --> 00:54:46,880
It's commonly good to use a previously existing framework or data format and you should prioritize

617
00:54:46,880 --> 00:54:53,120
that and use the formats that are common in your field instead of inventing something

618
00:54:53,120 --> 00:54:57,080
new.

619
00:54:57,080 --> 00:55:03,080
always a good idea to have a look around when you start a project. What are the data formats that

620
00:55:03,080 --> 00:55:09,880
are being used? Can I already clean up my initial data so that it's being that it's easier to use

621
00:55:09,880 --> 00:55:17,080
later on? Store it potentially in an efficient format if I need to reprocess it a lot of times

622
00:55:17,080 --> 00:55:26,880
and thereby save a bit of time. If you have this cleanup as a script you can

623
00:55:26,880 --> 00:55:39,880
reuse that script and you can reuse that even on new data. It's good to

624
00:55:39,880 --> 00:55:46,480
have important data also in a human readable format. It depends a bit

625
00:55:46,480 --> 00:55:54,080
on, this is a bit tricky because it sometimes depends a bit on how precise your data needs to be.

626
00:55:55,600 --> 00:56:01,440
So sometimes a human readable format might not be a good idea if you are working with numerical

627
00:56:01,440 --> 00:56:11,200
data and you need a very high precision. But at least the data that doesn't necessarily need

628
00:56:11,200 --> 00:56:16,000
need high precision or can be represented in a precise way in the

629
00:56:16,000 --> 00:56:20,480
human readable format, it's always a good idea to have that also in a human readable

630
00:56:20,480 --> 00:56:29,040
format to have an easy inspection. And finally, when you are done, provide the

631
00:56:29,040 --> 00:56:33,840
data that you have in a format that is easily used by other people and that

632
00:56:33,840 --> 00:56:39,960
commonly means by formats commonly used in your field. Even if they are not

633
00:56:39,960 --> 00:56:47,240
necessarily the best formats. You could for example think about I will be providing this

634
00:56:47,240 --> 00:56:55,640
both as a CSV and also in a binary format so that if someone really wants to get the

635
00:56:55,640 --> 00:57:01,920
exact things they can use the exact stuff while the CSV will be something that most

636
00:57:01,920 --> 00:57:09,480
people can use because it's commonly used in my field. So yeah I think with that we should

637
00:57:09,480 --> 00:57:18,760
hand over to [name]. Yes, definitely. We'll try to answer all the questions in the chat.

638
00:57:18,760 --> 00:57:24,400
There were lots of great questions. We'll try to add there an answer. But now we are

639
00:57:24,400 --> 00:57:29,080
going to hear a lot about plotting. Yeah, thanks a lot for this. Just give me a second

640
00:57:29,080 --> 00:57:41,800
to take over the screen share here. Just a moment. Here we go. And so thanks a lot for

641
00:57:41,800 --> 00:57:47,800
the session. Hi, everybody. Good morning. My name is [name] and we will stay in of course

642
00:57:47,800 --> 00:57:51,320
in Python, but we will also stay in with data.

643
00:57:51,320 --> 00:57:55,240
how the screen share is only black.

644
00:57:59,480 --> 00:58:03,280
This is the first time this has happened.

645
00:58:03,280 --> 00:58:06,920
Do you want to try re-sharing?

646
00:58:06,920 --> 00:58:08,320
Yes, let me try that.

647
00:58:16,640 --> 00:58:18,760
So technical difficulties, please stand by.

648
00:58:18,760 --> 00:58:20,040
Of course, we have tested this.

649
00:58:20,040 --> 00:58:22,060
but give me one more attempt here.

650
00:58:23,000 --> 00:58:26,080
In the meantime, there's lots of good questions

651
00:58:26,080 --> 00:58:31,080
about the data processing stuff here,

652
00:58:31,480 --> 00:58:33,280
or working with data.

653
00:58:33,280 --> 00:58:36,780
And I guess the other instructor,

654
00:58:36,780 --> 00:58:40,760
[name] and [name] will go through and do more.

655
00:58:40,760 --> 00:58:43,900
And yeah, the screen's still completely black.

656
00:58:45,160 --> 00:58:46,780
Is it still black?

657
00:58:50,040 --> 00:58:55,500
that's fascinating yeah this is it worked earlier today when we were

658
00:58:55,500 --> 00:59:10,920
preparing hmm is this some privacy thing that zoom okay just a sec here is the

659
00:59:10,920 --> 00:59:16,200
still black or anything change no still black and it doesn't show your name as

660
00:59:16,200 --> 00:59:28,960
the person whose screen is being shared so. Should I rejoin? Is there any other instructor

661
00:59:28,960 --> 00:59:34,200
here that can try sharing screen to make sure it's not? Can you stop the share and restart

662
00:59:34,200 --> 00:59:44,520
maybe? Yeah. So I stopped it. Sorry for the problems. Right now what you're seeing is

663
00:59:44,520 --> 00:59:51,080
the notes that's shared from my computer, not [name]'s computer. So, yeah.

664
00:59:54,360 --> 01:00:03,720
So should I try a reshare? I guess so. I actually have my other computer joined here.

665
01:00:06,680 --> 01:00:12,440
So it looks pretty normal on my side here. Okay, I have two computers that are showing

666
01:00:12,440 --> 01:00:17,880
black. Is anyone else in the instructor Zoom? Can you comment on what you see?

667
01:00:19,080 --> 01:00:26,600
Only black as well. Do you want somebody else to share the screen and run the try?

668
01:00:28,200 --> 01:00:33,000
Yeah, I guess [name] could give it a try. If [name] can...

669
01:00:35,080 --> 01:00:42,120
Okay. Yeah, so someone has the idea we could have a break now and then resume

670
01:00:42,440 --> 01:00:51,560
10 minutes. I propose we do the break now.

671
01:00:51,640 --> 01:01:01,200
Good. Okay, yeah, so I'll update the notes and see you in 10 minutes and hopefully

672
01:01:01,200 --> 01:01:06,360
we solve it until then. Yeah, okay, sounds good. See you. Bye.

673
01:01:12,440 --> 01:01:14,500
you

674
01:01:42,440 --> 01:01:44,500
you

675
01:02:12,440 --> 01:02:14,500
you

676
01:02:42,440 --> 01:02:44,500
you

677
01:03:12,440 --> 01:03:14,500
you

678
01:03:42,440 --> 01:03:44,500
you

679
01:04:12,440 --> 01:04:14,500
you

680
01:04:42,440 --> 01:04:44,500
you

681
01:05:12,440 --> 01:05:14,500
you

682
01:05:42,440 --> 01:05:44,500
you

683
01:06:12,440 --> 01:06:14,500
you

684
01:06:42,440 --> 01:06:44,500
you

685
01:07:12,440 --> 01:07:14,500
you

686
01:07:42,440 --> 01:07:44,500
you

687
01:08:12,440 --> 01:08:14,500
you

688
01:08:42,440 --> 01:08:44,500
you

689
01:09:12,440 --> 01:09:14,500
you

690
01:09:42,440 --> 01:09:44,500
you

691
01:10:12,440 --> 01:10:14,500
you

692
01:10:42,440 --> 01:11:03,520
Hello, we are back.

693
01:11:03,520 --> 01:11:06,720
Hi, everybody.

694
01:11:06,720 --> 01:11:11,760
Welcome back from the break and in the meantime, we found a workaround.

695
01:11:11,760 --> 01:11:16,200
I'm now hopefully sharing and you can hopefully see it and it's hopefully not

696
01:11:16,200 --> 01:11:24,360
just black. And we might adjust a little bit the sizing. So [name], my co-instructor

697
01:11:24,360 --> 01:11:28,760
here, will tell me if I need to add a little bit of space on the left or on

698
01:11:28,760 --> 01:11:33,240
top just that nothing is cut off. It should be made a little bit narrower.

699
01:11:33,240 --> 01:11:42,440
Okay let's do that. Yeah that's probably good. Okay yes so next is plotting with

700
01:11:42,440 --> 01:11:49,440
Vega-Altair. So what can you tell us about this? Yep so we'll talk about plotting

701
01:11:49,440 --> 01:11:54,120
data visualization. And so this is another way to look at data. But here we

702
01:11:54,120 --> 01:12:02,000
will plot it, visualize it. And we will spend so just slightly over over one

703
01:12:02,000 --> 01:12:08,780
hour on it and we will talk about the library called Vega-Altair, which is not

704
01:12:08,780 --> 01:12:12,380
maybe the one that you would expect. Maybe you expected

705
01:12:12,380 --> 01:12:18,100
that we talk about Matplotlib. Good news is that we have here lesson material for

706
01:12:18,100 --> 01:12:23,340
both, also exercises for both. So if you want to read up, if you are interested

707
01:12:23,340 --> 01:12:28,740
about Matplotlib, you can later. Here we will focus on Vega-Altair and I will

708
01:12:28,740 --> 01:12:31,980
also in a little bit explain why we do that,

709
01:12:31,980 --> 01:12:34,900
or why we try this.

710
01:12:34,900 --> 01:12:36,060
This is a bit of an experiment.

711
01:12:36,060 --> 01:12:40,200
This is the first time I teach this lesson in this context.

712
01:12:41,300 --> 01:12:43,780
One tool that we will need is,

713
01:12:43,780 --> 01:12:47,540
we will now work again in the JupyterLab, Jupyter notebook.

714
01:12:47,540 --> 01:12:51,040
So this is this interface that we have also used yesterday,

715
01:12:52,720 --> 01:12:55,580
but I now want to spend two minutes

716
01:12:55,580 --> 01:12:58,220
on reminding how do we start it up.

717
01:12:58,740 --> 01:13:09,660
So, if you have installed the software environment and activated it, and if you are now in the

718
01:13:09,660 --> 01:13:15,620
software environment, then now you can, with me, start up the JupyterLab.

719
01:13:15,620 --> 01:13:23,260
And I will do that here as well, JupyterLab.

720
01:13:23,260 --> 01:13:27,940
And this will open up a JupyterLab in my browser.

721
01:13:27,940 --> 01:13:31,620
worry if you haven't done this if you don't have the environment if you are

722
01:13:31,620 --> 01:13:37,060
unsure how to start it where to start it you can you can also participate in this

723
01:13:37,060 --> 01:13:42,940
episode and I will tell you how but let me hit enter and start up the Jupyter

724
01:13:42,940 --> 01:13:55,900
lap suspense I also took a surprisingly long time to start up when I was testing

725
01:13:55,900 --> 01:14:03,820
so mm-hmm that's interesting in the meantime what can you tell us about the

726
01:14:03,820 --> 01:14:10,900
different plotting episodes I will try something different I will here I will

727
01:14:10,900 --> 01:14:13,780
try this thing, because that worked for me earlier

728
01:14:13,780 --> 01:14:14,780
when I tried that.

729
01:14:16,840 --> 01:14:17,680
Oh, here we go.

730
01:14:18,800 --> 01:14:21,760
So what it does is I actually need to click on the link.

731
01:14:23,600 --> 01:14:25,180
And here I have it.

732
01:14:25,180 --> 01:14:26,020
Okay, yeah.

733
01:14:26,020 --> 01:14:27,320
Here I have the JupyterLab.

734
01:14:30,160 --> 01:14:31,640
So.

735
01:14:31,640 --> 01:14:34,300
Good, and now back to the plotting episode.

736
01:14:34,300 --> 01:14:35,140
Yeah.

737
01:14:37,160 --> 01:14:40,720
So maybe I want to tell people how,

738
01:14:40,720 --> 01:14:42,620
what to expect now in the next one hour

739
01:14:43,480 --> 01:14:45,580
and how to participate.

740
01:14:45,580 --> 01:14:48,920
So what you can expect is if we,

741
01:14:48,920 --> 01:14:52,480
we will try to do is two exercise sessions,

742
01:14:52,480 --> 01:14:55,760
two sessions where you can really try something hands-on,

743
01:14:55,760 --> 01:14:57,120
15 minutes, 20 minutes.

744
01:14:57,120 --> 01:14:59,080
So two times, maybe 15 minutes.

745
01:15:00,300 --> 01:15:03,040
Here before we will do a little bit of introduction

746
01:15:03,040 --> 01:15:04,640
and I also wanted to answer the question

747
01:15:04,640 --> 01:15:06,240
like why they got out there.

748
01:15:06,240 --> 01:15:11,000
And at the end, we will do a bit of discussion Q&A.

749
01:15:11,000 --> 01:15:15,080
We will do this in the, in the JupyterLab.

750
01:15:15,080 --> 01:15:20,080
So one, so then you can type with me

751
01:15:20,400 --> 01:15:24,740
when I paste in examples, you can do this as well.

752
01:15:24,740 --> 01:15:28,800
Another really nice way to participate is

753
01:15:28,800 --> 01:15:33,800
please ask us lots of questions in the collaborative notes.

754
01:15:34,260 --> 01:15:35,760
I will just scroll to the end.

755
01:15:36,240 --> 01:15:40,080
because the more questions here, the better.

756
01:15:40,080 --> 01:15:43,500
I'm in a different browser window on my screen.

757
01:15:43,500 --> 01:15:46,000
I'm looking at these and [name] is looking at these

758
01:15:46,000 --> 01:15:50,100
and we can, this will help us to keep this really engaging.

759
01:15:50,100 --> 01:15:53,600
So even if you don't want to like plot and type,

760
01:15:53,600 --> 01:15:55,120
you can ask here.

761
01:15:58,120 --> 01:15:58,960
Okay.

762
01:15:58,960 --> 01:16:00,840
But now let's talk about plotting.

763
01:16:00,840 --> 01:16:03,880
So the goal is here, having a bit of an overview

764
01:16:03,880 --> 01:16:06,080
of what different libraries exist on Python.

765
01:16:07,320 --> 01:16:12,320
And here we want to be able to read a data set from disk

766
01:16:14,040 --> 01:16:18,600
or from the internet, load it into a Pandas data frame.

767
01:16:18,600 --> 01:16:21,100
And we remember Pandas data frames from yesterday

768
01:16:22,320 --> 01:16:24,680
and then visualize it with this library

769
01:16:24,680 --> 01:16:25,780
called Vega out there.

770
01:16:27,040 --> 01:16:32,040
And one, so one nice thing is that also if you get lost,

771
01:16:32,040 --> 01:16:38,880
Also, if you get lost, if something doesn't work or something was too fast, all the steps

772
01:16:38,880 --> 01:16:42,800
that I will do, you can also retrace them here in this notebook.

773
01:16:42,800 --> 01:16:48,640
I will now not open it up, so spoiler alert, but everything is in there.

774
01:16:48,640 --> 01:16:55,800
And one aspect that is really important to me when doing plotting is reproducibility.

775
01:16:55,800 --> 01:17:00,800
and Python and JupyterLab and Vega out there

776
01:17:01,280 --> 01:17:06,120
is a really nice combination to get reproducible plots

777
01:17:07,040 --> 01:17:09,980
because then all the steps are scripted.

778
01:17:11,240 --> 01:17:12,920
And the idea is that,

779
01:17:14,320 --> 01:17:18,520
so what I'm trying to do when I create plots

780
01:17:18,520 --> 01:17:21,840
is to minimize manual tweaking.

781
01:17:21,840 --> 01:17:26,280
I want to have all the steps scripted.

782
01:17:26,280 --> 01:17:28,280
All the steps should be part of the notebook.

783
01:17:28,280 --> 01:17:32,760
So at the end, I get the plot that is in my publication

784
01:17:32,760 --> 01:17:34,960
or thesis or report.

785
01:17:37,320 --> 01:17:39,320
And this is important because sooner or later,

786
01:17:39,320 --> 01:17:44,320
we all get into the situation that we now get new data.

787
01:17:44,680 --> 01:17:47,220
We need to recreate these 50 plots.

788
01:17:48,100 --> 01:17:49,840
And now I don't want to do it manually.

789
01:17:49,840 --> 01:17:51,920
Now I just want to read the data

790
01:17:51,920 --> 01:17:54,420
and the 50 plots are updated.

791
01:17:58,800 --> 01:18:03,120
And yeah, so Vega-Altair is not the only plotting library

792
01:18:03,120 --> 01:18:04,720
nor is Matplotlib.

793
01:18:04,720 --> 01:18:08,960
Matplotlib is the potentially the most popular one,

794
01:18:08,960 --> 01:18:10,120
the most standard one.

795
01:18:11,160 --> 01:18:15,560
There are many libraries in Python that can do plotting.

796
01:18:15,560 --> 01:18:17,520
Here I listed the ones that I know of.

797
01:18:17,520 --> 01:18:20,060
I'm pretty sure that I have missed a couple of them.

798
01:18:21,160 --> 01:18:22,800
There is not the one perfect one.

799
01:18:24,420 --> 01:18:27,460
Vega-Altair is not better than other libraries.

800
01:18:27,460 --> 01:18:29,420
It's really a matter of your preference.

801
01:18:30,460 --> 01:18:32,740
One thing I encourage you to do is to also browse these

802
01:18:32,740 --> 01:18:35,820
and see which one fits your workflow,

803
01:18:35,820 --> 01:18:40,820
which one do you like best and then choose it.

804
01:18:40,940 --> 01:18:43,820
But now why do I want to present Vega-Altair

805
01:18:43,820 --> 01:18:44,940
here in this workshop?

806
01:18:44,940 --> 01:18:47,700
The things that I like about this library

807
01:18:47,700 --> 01:18:52,700
is that it's modern, it's concise, it's very powerful,

808
01:18:54,220 --> 01:18:56,600
but the interface, so the API,

809
01:18:57,900 --> 01:19:02,460
the interface is relatively simple, it's consistent,

810
01:19:03,520 --> 01:19:07,060
it's predictable, and I like to think

811
01:19:07,060 --> 01:19:11,180
that it lets me focus on the data visualization part,

812
01:19:11,180 --> 01:19:14,800
and I can get started without too much Python knowledge.

813
01:19:14,800 --> 01:19:16,840
I have a feeling that some other libraries

814
01:19:16,840 --> 01:19:18,720
require more Python knowledge.

815
01:19:20,760 --> 01:19:25,760
I like how it combines visual channels with data columns.

816
01:19:26,720 --> 01:19:31,200
So in our Pandas data frames, we have data columns.

817
01:19:32,760 --> 01:19:35,880
And I will try to show you that the connection

818
01:19:35,880 --> 01:19:37,920
between data columns and visual channels

819
01:19:37,920 --> 01:19:39,520
can feel really intuitive.

820
01:19:41,360 --> 01:19:43,400
And this is really motivation number one for me

821
01:19:43,400 --> 01:19:45,160
to show this library.

822
01:19:46,580 --> 01:19:50,000
I will hopefully be able to motivate that it's,

823
01:19:50,000 --> 01:19:52,160
we will see that it's easy to change figures.

824
01:19:52,160 --> 01:19:55,240
There is very good documentation, it's open source.

825
01:19:55,240 --> 01:19:58,480
You can then save figures in a number of formats,

826
01:19:58,480 --> 01:19:59,860
even as websites.

827
01:20:00,920 --> 01:20:04,160
And you can even create interactive plots

828
01:20:04,160 --> 01:20:09,160
and save it as a website and then display it in your,

829
01:20:09,280 --> 01:20:11,680
I don't know, personal webpage or group webpage.

830
01:20:11,680 --> 01:20:18,840
So, usually, and in the past, we've taught matplotlib here.

831
01:20:18,840 --> 01:20:23,080
So I guess maybe that's a question everyone wants to know.

832
01:20:23,080 --> 01:20:28,720
So why Vega-Altair right now instead of matplotlib?

833
01:20:28,720 --> 01:20:33,160
What's the advantages and disadvantages of each?

834
01:20:33,160 --> 01:20:42,760
Yeah, the advantage is that I wanted to have a library that understands Pandas DataFrames

835
01:20:42,760 --> 01:20:51,000
natively, so that we have a nice connection to the tools that we learned yesterday.

836
01:20:51,000 --> 01:20:59,840
In Matplotlib it is also possible to use Pandas DataFrames, but it is not, like I feel you

837
01:20:59,840 --> 01:21:01,340
you have to do some extra steps.

838
01:21:01,340 --> 01:21:02,340
Yeah.

839
01:21:02,340 --> 01:21:03,340
Okay.

840
01:21:03,340 --> 01:21:13,280
The, what I've also found with Matplotlib was that, that you need maybe more Python

841
01:21:13,280 --> 01:21:17,960
knowledge to be able to tweak plots and change plots.

842
01:21:17,960 --> 01:21:18,960
Okay.

843
01:21:18,960 --> 01:21:19,960
Yeah.

844
01:21:19,960 --> 01:21:28,120
So, so maybe in short, I, I find Vega-Altera is maybe simpler for beginners in Python.

845
01:21:28,120 --> 01:21:34,520
So it's also declarative as opposed to matplotlib, where you might be spending a lot of time

846
01:21:34,520 --> 01:21:37,080
making it look just like you want.

847
01:21:37,080 --> 01:21:38,080
Correct.

848
01:21:38,080 --> 01:21:48,120
So Vega-outer is declarative, meaning that we describe what we want and not so much like

849
01:21:48,120 --> 01:21:52,580
do this step by step, like this step and that step.

850
01:21:52,580 --> 01:21:58,980
But then to get, I think we need to also be fair that to get like publication quality

851
01:21:58,980 --> 01:22:05,240
plots where you tweak the font size and you tweak everything absolutely to your liking,

852
01:22:05,240 --> 01:22:09,700
you will spend time on it, independently of which library you use.

853
01:22:09,700 --> 01:22:10,700
Yeah.

854
01:22:10,700 --> 01:22:11,700
Yeah.

855
01:22:11,700 --> 01:22:12,700
Okay.

856
01:22:12,700 --> 01:22:14,020
So I'm interested.

857
01:22:14,020 --> 01:22:16,140
So how do we begin?

858
01:22:16,140 --> 01:22:23,100
I would like to start with our example data set, which is weather data.

859
01:22:23,100 --> 01:22:26,820
I think this is data that we all can relate to.

860
01:22:26,820 --> 01:22:31,380
I wanted to have a data set that is relatively easy to understand.

861
01:22:31,380 --> 01:22:38,100
And it's a data set that contains weather data from two Norwegian cities.

862
01:22:38,100 --> 01:22:41,620
Here is some documentation of how I obtained it, but if you want to look at the data set,

863
01:22:41,620 --> 01:22:45,240
you can open up this link and I will do that here.

864
01:22:45,240 --> 01:22:54,880
The data set is in CSV format, so there are two Norwegian cities, one is Oslo, the capital,

865
01:22:54,880 --> 01:22:59,840
the other one is Tromsø, this is the place where I work, it's in the north of Norway.

866
01:22:59,840 --> 01:23:03,560
There is some monthly data, some daily data, I will now just open up maybe the monthly

867
01:23:03,560 --> 01:23:06,220
one.

868
01:23:06,220 --> 01:23:13,080
And it contains information about weather station, the date, and some like temperature

869
01:23:13,080 --> 01:23:20,100
temperature, precipitation, like how much rain, minimum temperature.

870
01:23:20,100 --> 01:23:26,780
Here it's presented in a tabular form, but really the underlying format is CSV, comma

871
01:23:26,780 --> 01:23:27,860
separated values.

872
01:23:27,860 --> 01:23:30,540
So this is how it is really stored.

873
01:23:30,540 --> 01:23:34,380
It's values separated by commas.

874
01:23:34,380 --> 01:23:40,220
And the first row describes the rows.

875
01:23:40,220 --> 01:23:47,500
So now we will try to, we will read the CSV file using Pandas directly from the web.

876
01:23:47,500 --> 01:23:52,780
So we don't have to even save it on our disk and try to plot it.

877
01:23:52,780 --> 01:23:59,940
And now if you want, so if everybody wants, you can now do this with me.

878
01:23:59,940 --> 01:24:03,220
But if you just want to watch, you can also just watch what I do.

879
01:24:03,220 --> 01:24:11,480
And then in the exercise session, you will have enough time to retrace these steps.

880
01:24:11,480 --> 01:24:21,860
So I will now copy this block which imports pandas and then it reads these two data sets,

881
01:24:21,860 --> 01:24:28,420
the monthly data set for the city Tromso and for the city Oslo into a data frame which

882
01:24:28,420 --> 01:24:32,980
I called data monthly.

883
01:24:32,980 --> 01:24:36,420
So I will now copy it into my notebook, and we will then have a look at this data, we

884
01:24:36,420 --> 01:24:37,940
will try to plot it.

885
01:24:37,940 --> 01:24:50,620
Okay, let me just rearrange here a little bit the window so that we see both.

886
01:24:50,620 --> 01:24:59,380
And the first thing I will do is I will rename the notebook from Untitled to Plotting, Rename,

887
01:24:59,380 --> 01:25:04,980
And I will copy paste this in.

888
01:25:04,980 --> 01:25:08,380
And this line lets me like look at the data.

889
01:25:08,380 --> 01:25:11,700
So I will now run this cell.

890
01:25:11,700 --> 01:25:20,100
What I do here on my side is shift enter to run it and create a cell below.

891
01:25:20,100 --> 01:25:24,700
And yeah, here's the data.

892
01:25:24,700 --> 01:25:33,060
And just to make it a little bit more readable, I will now make this larger.

893
01:25:33,060 --> 01:25:41,260
One modification is that, so something I like to do with data is, here data monthly, I like

894
01:25:41,260 --> 01:25:50,520
to actually look at the types, .dtypes, this is a little recap from yesterday.

895
01:25:50,520 --> 01:25:59,200
Because it tells me what is the, for instance, I will see here that it actually doesn't understand

896
01:25:59,200 --> 01:26:00,920
that the date is really date format.

897
01:26:00,920 --> 01:26:03,800
It thinks that the date is a number.

898
01:26:03,800 --> 01:26:08,600
And so it will now, for instance, think that this is one point and these are some decimal

899
01:26:08,600 --> 01:26:09,600
points.

900
01:26:09,600 --> 01:26:13,320
But of course, this is January 2023.

901
01:26:13,320 --> 01:26:22,440
So I want to do a little modification to tell pandas that this is, that the column here

902
01:26:22,440 --> 01:26:27,960
is in date format.

903
01:26:27,960 --> 01:26:35,040
And if I print it again, it will look better.

904
01:26:35,040 --> 01:26:41,160
Now I see that the date is year, month, day.

905
01:26:41,160 --> 01:26:45,480
And so far we didn't do any plotting yet, but now we are ready to do some plotting.

906
01:26:45,480 --> 01:26:48,180
Here plotting the data.

907
01:26:48,180 --> 01:26:54,200
And I will copy-paste a little bit of code, and we look at the result, and I will also

908
01:26:54,200 --> 01:26:56,500
explain what's happening here.

909
01:26:56,500 --> 01:26:59,160
So let me copy this code block here into the notebook.

910
01:26:59,160 --> 01:27:10,180
Okay, so this does, out there, a chart, monthly data, mark bar, code.

911
01:27:10,180 --> 01:27:12,820
and maybe I should make it larger.

912
01:27:12,820 --> 01:27:14,340
So we got a bar chart.

913
01:27:14,340 --> 01:27:16,100
It's actually not a great bar chart

914
01:27:16,100 --> 01:27:20,780
because here for different months of the year,

915
01:27:20,780 --> 01:27:21,900
I got the precipitation.

916
01:27:21,900 --> 01:27:25,280
So how much rain in millimeter, I guess.

917
01:27:27,060 --> 01:27:30,400
Here, Tromso is in orange, Oslo is in blue.

918
01:27:31,260 --> 01:27:32,420
The one thing that is not ideal

919
01:27:32,420 --> 01:27:35,260
is that it stacks them on top of each other,

920
01:27:35,260 --> 01:27:36,780
which makes it now very hard for me

921
01:27:36,780 --> 01:27:41,780
to compare an amount of rain between months for Oslo.

922
01:27:44,260 --> 01:27:45,980
But before improving it,

923
01:27:47,740 --> 01:27:51,100
I want to explain a little bit what's happening.

924
01:27:51,100 --> 01:27:51,940
So what did we do?

925
01:27:51,940 --> 01:27:56,160
I imported this bigger Altair plotting library.

926
01:27:57,540 --> 01:27:59,100
I gave it a shortcut name.

927
01:27:59,100 --> 01:28:01,620
So I renamed it as Alt.

928
01:28:01,620 --> 01:28:04,560
So then here I can refer to it.

929
01:28:04,560 --> 01:28:06,020
Instead of typing Altair,

930
01:28:06,020 --> 01:28:09,180
I only have to type ALT.

931
01:28:09,180 --> 01:28:11,660
And I did that because when you then browse the internet,

932
01:28:11,660 --> 01:28:13,960
this is what you are likely to see as examples.

933
01:28:13,960 --> 01:28:16,300
So I want it to be close to that documentation.

934
01:28:18,580 --> 01:28:22,240
So we import some functionality to plot,

935
01:28:22,240 --> 01:28:23,180
and here I use it.

936
01:28:23,180 --> 01:28:27,020
And this module comes with a bunch of functions.

937
01:28:27,020 --> 01:28:30,000
One of them is here a chart.

938
01:28:31,260 --> 01:28:35,420
So I want to create a chart, and here I put the data in.

939
01:28:35,420 --> 01:28:37,520
This is the pandas data frame.

940
01:28:39,060 --> 01:28:41,580
And then I do a couple of things with it.

941
01:28:41,580 --> 01:28:45,200
This here, I decide I want to have a bar chart.

942
01:28:45,200 --> 01:28:46,620
And later I will show you also

943
01:28:46,620 --> 01:28:48,640
how do you get other types of charts.

944
01:28:50,020 --> 01:28:55,020
And this part is the part where I link or encode.

945
01:28:56,060 --> 01:28:59,940
So I connect the columns of the table.

946
01:29:02,940 --> 01:29:04,840
And the columns of the table are here.

947
01:29:05,420 --> 01:29:10,700
so there is a column called date and there is a column called precipitation and a column called

948
01:29:10,700 --> 01:29:18,300
name and i connect them to the visual channel and the visual channel is for instance the x

949
01:29:18,300 --> 01:29:30,460
coordinate y coordinate color and i will do a little improvement here

950
01:29:30,460 --> 01:29:40,960
and I will explain why I did that year month this is month this is a function

951
01:29:40,960 --> 01:29:49,860
that Altair provides okay so it's like pre-processing the column value it will

952
01:29:49,860 --> 01:29:57,260
into it will now tell me that this is October 22 it will plot both the month

953
01:29:57,260 --> 01:30:00,940
and the year at the same time.

954
01:30:00,940 --> 01:30:08,820
What does this T mean here is that I tell Altair that this is a temporal data.

955
01:30:08,820 --> 01:30:13,860
And there are other types like quantitative, ordinal, nominal, GeoJSON.

956
01:30:13,860 --> 01:30:16,140
I will now not go into details and explain all of them.

957
01:30:16,140 --> 01:30:19,180
I only wanted to tell you what this T means.

958
01:30:19,180 --> 01:30:22,900
I wanted to tell the plotting library that this is a time series.

959
01:30:22,900 --> 01:30:29,900
And does it have different presets for the different types of data, I guess?

960
01:30:29,900 --> 01:30:34,060
Yes, exactly.

961
01:30:34,060 --> 01:30:37,840
And we will see that in action.

962
01:30:37,840 --> 01:30:39,780
But now I want to improve this a bit.

963
01:30:39,780 --> 01:30:45,420
One improvement I want to do is to not have them on top of each other, but have them side

964
01:30:45,420 --> 01:30:48,600
by side.

965
01:30:48,600 --> 01:30:55,160
And the improvement that I will do is I will add another visual channel called column and

966
01:30:55,160 --> 01:30:59,520
connect it to name.

967
01:30:59,520 --> 01:31:09,320
And if I run, if I run the cell, now the names of the cities of the stations appear in different

968
01:31:09,320 --> 01:31:11,480
columns of the plot.

969
01:31:11,480 --> 01:31:16,960
And you can already guess what will happen if I change this to row.

970
01:31:16,960 --> 01:31:22,280
Maybe that's a question to my co-instructor, and what do you think will happen now?

971
01:31:22,280 --> 01:31:25,560
Does it put two plots on top of each other?

972
01:31:25,560 --> 01:31:26,560
Exactly.

973
01:31:26,560 --> 01:31:27,560
So that's...

974
01:31:27,560 --> 01:31:28,560
Yeah, okay.

975
01:31:28,560 --> 01:31:33,000
Ah, so yeah, now it lines up vertically.

976
01:31:33,000 --> 01:31:38,840
So you used the word channel here, so is this basically you take different columns and you

977
01:31:38,840 --> 01:31:44,880
connect them with different channels, whether it's color, or x or y axis, or stacked next

978
01:31:44,880 --> 01:31:47,480
to each other, and so on.

979
01:31:47,480 --> 01:31:48,000
Precisely.

980
01:31:48,000 --> 01:31:52,920
And this is really what I like about this library,

981
01:31:52,920 --> 01:31:55,880
that it makes it intuitive to me.

982
01:31:55,880 --> 01:32:01,520
So all I do is connect columns of my data sets

983
01:32:01,520 --> 01:32:03,120
to visual channels.

984
01:32:03,120 --> 01:32:05,960
Of course, I need to know what kind of visual channels exist.

985
01:32:05,960 --> 01:32:07,840
And I will, in a moment, show you

986
01:32:07,840 --> 01:32:11,280
an overview of the different visual channels.

987
01:32:11,280 --> 01:32:13,560
Here, I will do one more modification,

988
01:32:13,560 --> 01:32:16,200
which is instead of column,

989
01:32:16,200 --> 01:32:19,120
I can, there is another visual channel called X offset.

990
01:32:20,760 --> 01:32:24,660
And if I use that one, I get a stacked bar chart.

991
01:32:24,660 --> 01:32:27,080
And now it makes it easier for me to compare

992
01:32:27,080 --> 01:32:30,940
the rain amount between the two cities.

993
01:32:37,360 --> 01:32:42,360
So, yeah, maybe a couple of more examples

994
01:32:42,360 --> 01:32:46,040
examples and then I want to show you what

995
01:32:46,040 --> 01:32:50,360
what different visual channels exist and also what different

996
01:32:50,360 --> 01:32:56,840
mark options exist. I want to now show you an example where I

997
01:32:56,840 --> 01:33:00,200
change from a bar chart

998
01:33:00,680 --> 01:33:05,160
from a bar chart I go to what happens if we do

999
01:33:05,160 --> 01:33:08,840
mark area

1000
01:33:08,840 --> 01:33:21,680
we make it a little bit transparent 0.5 and now I will have to why I want to

1001
01:33:21,680 --> 01:33:29,720
have min temperature no max max temperature min temperature does it mean

1002
01:33:29,720 --> 01:33:38,440
we're making well I guess we'll see what comes out of that yeah ah okay so

1003
01:33:38,440 --> 01:33:49,720
So what I did, I took now different columns from my dataset.

1004
01:33:49,720 --> 01:33:55,400
And now there is a different chart type called an area chart.

1005
01:33:55,400 --> 01:34:02,880
And I connected the visual channels to those different columns.

1006
01:34:02,880 --> 01:34:10,920
One thing that you can try in the exercise block will be to separate now, okay, what

1007
01:34:10,920 --> 01:34:11,920
do we see here?

1008
01:34:11,920 --> 01:34:15,920
We see, like, what our temperature range is for the different months for the two different

1009
01:34:15,920 --> 01:34:16,920
cities.

1010
01:34:16,920 --> 01:34:22,320
So how do you know all of these different channels and so on?

1011
01:34:22,320 --> 01:34:24,400
Is it something you look up?

1012
01:34:24,400 --> 01:34:29,320
Because this seems almost like magic, but I wouldn't know the magic words to say to

1013
01:34:29,320 --> 01:34:30,320
get it out.

1014
01:34:30,320 --> 01:34:31,320
Yeah.

1015
01:34:31,320 --> 01:34:34,480
So I admit that I don't remember them.

1016
01:34:34,480 --> 01:34:36,280
I cannot remember them.

1017
01:34:36,280 --> 01:34:38,800
And the goal of this session is not to remember them,

1018
01:34:38,800 --> 01:34:40,800
but to know where to find them.

1019
01:34:40,800 --> 01:34:44,960
And here I link to an overview

1020
01:34:44,960 --> 01:34:46,520
of the available visual channels.

1021
01:34:46,520 --> 01:34:47,520
Let's have a quick look.

1022
01:34:47,520 --> 01:34:48,520
I will open it up.

1023
01:34:51,400 --> 01:34:54,360
So there is, we have seen X, Y,

1024
01:34:54,360 --> 01:34:56,600
we have seen Y2 for the area chart.

1025
01:34:57,600 --> 01:34:59,520
We have seen X offset,

1026
01:34:59,520 --> 01:35:03,720
But there is a lot more.

1027
01:35:03,720 --> 01:35:07,640
There is, you know, angle color.

1028
01:35:07,640 --> 01:35:11,240
You can, you can do like different shapes.

1029
01:35:11,240 --> 01:35:15,360
Or if you do circles, you can have a different radius.

1030
01:35:15,360 --> 01:35:18,160
There is really a ton you can do.

1031
01:35:18,160 --> 01:35:19,760
So these are visual channels.

1032
01:35:19,760 --> 01:35:24,120
And I don't remember them, I looked them up.

1033
01:35:24,120 --> 01:35:27,600
Then we have used two different marks.

1034
01:35:27,600 --> 01:35:28,600
One was bar chart.

1035
01:35:28,600 --> 01:35:34,280
one was an area chart. And also I don't remember there what are all the available marks.

1036
01:35:34,280 --> 01:35:43,800
So does a mark basically say like this is how we want it to be? Like we want it roughly like...

1037
01:35:44,920 --> 01:35:48,280
Yeah, it's like the type of the type of the plot.

1038
01:35:48,280 --> 01:35:49,080
Okay, okay.

1039
01:35:49,080 --> 01:35:55,400
And here I list them. For instance, an area chart, a bar chart, or you can have a scatter plot,

1040
01:35:55,400 --> 01:35:59,800
line plot, box plot.

1041
01:35:59,800 --> 01:36:01,880
Yeah.

1042
01:36:01,880 --> 01:36:05,960
OK, so it comes in, we make the chart object,

1043
01:36:05,960 --> 01:36:09,080
we mark it with the general class of plot,

1044
01:36:09,080 --> 01:36:12,520
whether it's bar or area or something.

1045
01:36:12,520 --> 01:36:15,240
We can give it other annotations,

1046
01:36:15,240 --> 01:36:24,040
and then we connect columns as data channels to outputs.

1047
01:36:24,040 --> 01:36:28,440
And the data has to be tidy. I guess that's the whole point here.

1048
01:36:28,440 --> 01:36:32,920
It helps a lot. Thanks for reminding this, because it helps a lot if the data is tidy.

1049
01:36:34,440 --> 01:36:37,960
If the data is tidy, and there is some discussion on it in the notes,

1050
01:36:39,000 --> 01:36:42,040
about tidy data, and also it has been mentioned earlier today and yesterday,

1051
01:36:43,240 --> 01:36:47,480
then you will see that it's very easy now to change the type of the plot.

1052
01:36:48,280 --> 01:36:52,200
And I like to do that, so I can then experiment until I find the plot that I like the best.

1053
01:36:52,200 --> 01:37:00,760
And here, at this stage, I also admit that what I really do in when I do these plots,

1054
01:37:00,760 --> 01:37:04,880
I often start from the gallery of examples.

1055
01:37:04,880 --> 01:37:09,000
And I like this, this thing here, I guess, just like with matplotlib, or with any other

1056
01:37:09,000 --> 01:37:15,960
plotting library, I normally look at gallery of examples, I will find the one that looks

1057
01:37:15,960 --> 01:37:19,360
closest to what I have in mind.

1058
01:37:19,360 --> 01:37:21,760
And this is this will be my starting point.

1059
01:37:21,760 --> 01:37:24,840
And we will try that later.

1060
01:37:26,480 --> 01:37:29,840
What I would like to do now is that to give here

1061
01:37:30,760 --> 01:37:34,560
workshop participants a bit of time, maybe 15 minutes.

1062
01:37:35,920 --> 01:37:38,920
And in these 15 minutes, the goal would be that

1063
01:37:40,180 --> 01:37:41,020
if you want to catch up,

1064
01:37:41,020 --> 01:37:43,800
if you want to try some of the plots that I did

1065
01:37:43,800 --> 01:37:47,100
here in the notebook, you can try that.

1066
01:37:47,100 --> 01:37:57,220
Then, to practice a little bit, to have a bit of understanding of these visual channels,

1067
01:37:57,220 --> 01:38:06,340
I will ask you then to, instead of having a stacked bar chart along the x-axis, try

1068
01:38:06,340 --> 01:38:13,180
to get it along the y-axis, with, and you will only have to change two lines of your

1069
01:38:13,180 --> 01:38:23,820
plotting code. Then some more questions. Try to ask the Internet or your AI tool how to

1070
01:38:23,820 --> 01:38:31,460
change the x-axis from precipitation to precipitation millimeters. So you can try that. And then

1071
01:38:31,460 --> 01:38:36,980
you can also try to split these temperature ranges instead of being on top of each other.

1072
01:38:36,980 --> 01:38:41,580
Try to split them so that they are next to each other. And this will give us a really

1073
01:38:41,580 --> 01:38:46,820
good understanding of good control over these visual channels.

1074
01:38:46,820 --> 01:38:49,660
And don't be afraid to use the solution for this.

1075
01:38:49,660 --> 01:38:54,500
So also one way to go through the exercises to actually open up the solution and, and

1076
01:38:54,500 --> 01:38:58,700
try to go through these solutions step by step.

1077
01:38:58,700 --> 01:38:59,700
Yeah.

1078
01:38:59,700 --> 01:39:05,460
And then we will, so you will get 15 minutes, we will then come back, talk a little bit

1079
01:39:05,460 --> 01:39:06,460
about it.

1080
01:39:06,460 --> 01:39:08,480
I will then tell you a little bit more

1081
01:39:08,480 --> 01:39:13,480
and then we will go into really imagining real life.

1082
01:39:14,360 --> 01:39:16,920
We start with, I will show you how I start

1083
01:39:16,920 --> 01:39:21,840
from a gallery example and get my own data into it.

1084
01:39:21,840 --> 01:39:24,420
That will be a second exercise block later.

1085
01:39:26,680 --> 01:39:31,680
So here in the notes, we will add exercise.

1086
01:39:31,760 --> 01:39:36,120
It will be until 40 minutes past.

1087
01:39:36,460 --> 01:39:43,680
So we will resume XX40.

1088
01:39:43,680 --> 01:39:50,080
And in there I will also paste the link to the exercise and a short description of what

1089
01:39:50,080 --> 01:39:51,080
we expect.

1090
01:39:51,080 --> 01:39:52,280
And then we'll be back.

1091
01:39:52,280 --> 01:40:00,400
So the goal is to explore some, whatever you feel like you have time to.

1092
01:40:00,400 --> 01:40:05,840
Yeah, this exercise here, I will paste it into the notes.

1093
01:40:05,840 --> 01:40:10,600
Also try, here there are questions one, two, three, four, try some of them, all of them,

1094
01:40:10,600 --> 01:40:13,720
and the solution is there.

1095
01:40:13,720 --> 01:40:18,000
And also just question one is already good if you manage that.

1096
01:40:18,000 --> 01:40:19,000
See you in 15 minutes.

1097
01:40:19,000 --> 01:40:23,880
And in the meantime, I will catch up with the notes so that we can answer some questions.

1098
01:40:23,880 --> 01:40:24,880
See you then.

1099
01:40:24,880 --> 01:40:25,880
Bye.

1100
01:40:25,880 --> 01:40:26,380
Bye.

1101
01:40:35,840 --> 01:40:37,900
you

1102
01:41:05,840 --> 01:41:07,900
you

1103
01:41:35,840 --> 01:41:37,900
you

1104
01:42:05,840 --> 01:42:07,900
you

1105
01:42:35,840 --> 01:42:37,900
you

1106
01:43:05,840 --> 01:43:07,900
you

1107
01:43:35,840 --> 01:43:37,900
you

1108
01:44:05,840 --> 01:44:07,900
you

1109
01:44:35,840 --> 01:44:37,900
you

1110
01:45:05,840 --> 01:45:07,900
you

1111
01:45:35,840 --> 01:45:37,900
you

1112
01:46:05,840 --> 01:46:07,900
you

1113
01:46:35,840 --> 01:46:37,900
you

1114
01:47:05,840 --> 01:47:07,900
you

1115
01:47:35,840 --> 01:47:37,900
you

1116
01:48:05,840 --> 01:48:07,900
you

1117
01:48:35,840 --> 01:48:37,900
you

1118
01:49:05,840 --> 01:49:07,900
you

1119
01:49:35,840 --> 01:49:37,900
you

1120
01:50:05,840 --> 01:50:07,900
you

1121
01:50:35,840 --> 01:50:37,900
you

1122
01:51:05,840 --> 01:51:07,900
you

1123
01:51:35,840 --> 01:51:37,900
you

1124
01:52:05,840 --> 01:52:07,900
you

1125
01:52:35,840 --> 01:52:37,900
you

1126
01:53:05,840 --> 01:53:07,900
you

1127
01:53:35,840 --> 01:53:37,900
you

1128
01:54:05,840 --> 01:54:07,900
you

1129
01:54:35,840 --> 01:54:37,900
you

1130
01:55:05,840 --> 01:55:07,900
you

1131
01:55:35,840 --> 01:55:37,900
you

1132
01:56:05,840 --> 01:56:35,440
So, if we look here at the notes, we see there have been some good questions there.

1133
01:56:35,440 --> 01:56:44,660
Yeah, the most interesting to me was this, can you define a visual channel?

1134
01:56:44,660 --> 01:56:53,520
Because somehow I think that's like the most, well, the most unique thing I see here.

1135
01:56:53,520 --> 01:56:57,840
And the answer here is it's like the different ways eyes tell things apart, whether it's

1136
01:56:57,840 --> 01:57:06,400
color or size or offsets or position like x y position something like that um

1137
01:57:06,400 --> 01:57:10,640
do you have any comments on that i think that's a really good explanation

1138
01:57:10,640 --> 01:57:17,760
um i can only add to it that those of you who maybe program in r the r

1139
01:57:17,760 --> 01:57:22,720
language if you plot in r you likely plot so

1140
01:57:22,720 --> 01:57:27,520
there is a library called ggplot2 and the philosophy there is very

1141
01:57:27,520 --> 01:57:33,840
similar. So those of you who come from R, maybe come from ggplot2, maybe you feel at home this

1142
01:57:33,840 --> 01:57:40,480
philosophy of visual channels. But that was a good description of it. I'm not sure I have a

1143
01:57:40,480 --> 01:57:46,160
better one. It's really about like shapes, placements, sizes, colors. And like while it's

1144
01:57:46,160 --> 01:57:52,160
sort of the same in matplotlib, which I've tried to use before, here it seems like a much more

1145
01:57:52,160 --> 01:57:59,280
natural mapping, instead of having to add a bunch of other lines to get the matplotlib

1146
01:57:59,280 --> 01:58:00,760
ones connected.

1147
01:58:00,760 --> 01:58:07,960
Anyway, I think most of the rest of the questions are answered here somewhat well.

1148
01:58:07,960 --> 01:58:10,760
So I'll head back to your screen.

1149
01:58:10,760 --> 01:58:13,840
Thanks.

1150
01:58:13,840 --> 01:58:19,280
My plan is to have a little bit more fun here with visual channels.

1151
01:58:19,280 --> 01:58:24,560
discussion I will then, we have this one more exercise session but we decided

1152
01:58:24,560 --> 01:58:30,120
that the second exercise plot I will do as a demo here. We will do it

1153
01:58:30,120 --> 01:58:38,600
together but on my screen. So I wanted to show you a few more examples. Here I will

1154
01:58:38,600 --> 01:58:43,080
not copy-paste it into the notebook, you can you can try that on your own time.

1155
01:58:43,080 --> 01:58:48,380
It's very similar to above, but now I use the daily data.

1156
01:58:48,380 --> 01:58:55,600
So again, I load tabular data from the internet, again to cities, now daily.

1157
01:58:55,600 --> 01:59:07,100
Daily data, I will be now interested in snow depth, so how much snow is on the ground.

1158
01:59:07,100 --> 01:59:12,100
And here, in this example, I did a preliminary plot.

1159
01:59:13,500 --> 01:59:15,420
Again, how do I read it?

1160
01:59:15,420 --> 01:59:16,580
I use this library.

1161
01:59:16,580 --> 01:59:18,060
I want the chart.

1162
01:59:18,060 --> 01:59:19,140
This is my data.

1163
01:59:20,900 --> 01:59:22,300
I want to have a bar chart.

1164
01:59:23,420 --> 01:59:26,300
On the x-axis, I want to have the date.

1165
01:59:27,860 --> 01:59:32,040
So this was December 2022,

1166
01:59:32,940 --> 01:59:34,600
and then a couple of months.

1167
01:59:34,600 --> 01:59:41,800
There was less snow here in Oslo, more snow in Tromso.

1168
01:59:41,800 --> 01:59:47,020
You can also see that we have then snow well into April and May.

1169
01:59:47,020 --> 01:59:50,020
I connected the y-axis with the snow depth.

1170
01:59:50,020 --> 01:59:54,500
Snow depth is a column in this data set.

1171
01:59:54,500 --> 01:59:56,800
And then I wanted to have them side by side.

1172
01:59:56,800 --> 02:00:04,320
So the name of the station, left Oslo, right Tromso.

1173
02:00:04,320 --> 02:00:08,760
And here I wanted to, I can then add additional visual channels.

1174
02:00:08,760 --> 02:00:12,200
I wanted to add a visual channel color.

1175
02:00:12,200 --> 02:00:20,040
I wanted to color the bar chart with the maximum temperature, the daily maximum temperature.

1176
02:00:20,040 --> 02:00:24,120
And then it starts to look really interesting.

1177
02:00:24,120 --> 02:00:30,880
This is done temperature from, I don't know, minus five to 15.

1178
02:00:30,880 --> 02:00:33,640
I also wanted to show you that you can modify

1179
02:00:33,640 --> 02:00:34,760
the color range.

1180
02:00:34,760 --> 02:00:38,080
Here I got some default color scale,

1181
02:00:38,080 --> 02:00:39,320
but you can modify this.

1182
02:00:40,280 --> 02:00:41,280
So in this example,

1183
02:00:41,280 --> 02:00:44,440
I changed it to a color scheme called plasma.

1184
02:00:46,120 --> 02:00:48,400
And here I have a link,

1185
02:00:48,400 --> 02:00:51,040
which links to the available color schemes,

1186
02:00:51,040 --> 02:00:52,140
and there are many.

1187
02:00:53,680 --> 02:00:55,220
So there are very many color schemes,

1188
02:00:55,220 --> 02:00:57,620
and you can then choose one that is appropriate

1189
02:00:57,620 --> 02:01:05,620
visually pleasing for your example. And what I like about this plasma plot is

1190
02:01:05,620 --> 02:01:13,020
that so there is no depth. Let's look at Tromso. Snow goes up one meter, one

1191
02:01:13,020 --> 02:01:17,820
meter, 20 centimeters. It melts and it disappears. What I like about this plot

1192
02:01:17,820 --> 02:01:24,220
is that I can see that on the warmer days, which are then more yellow, so the warmer

1193
02:01:24,220 --> 02:01:28,640
days I follow they are typically followed by less snow and the colder days

1194
02:01:28,640 --> 02:01:34,480
they are often followed by more snow. Nice visualization. And then if I realize

1195
02:01:34,480 --> 02:01:38,640
that I'm not sure about the bar charts I want to have how does it look with with

1196
02:01:38,640 --> 02:01:44,000
a circle scatter plot then the only thing I changed here was from mark bar

1197
02:01:44,000 --> 02:01:49,320
you can change to mark circle and then I get circles. So it's a really nice way

1198
02:01:49,320 --> 02:01:55,800
of experimenting until you find the visualization that conveys the message

1199
02:01:55,800 --> 02:02:05,240
that you want to convey. Now we have 15 minutes left. Yes, I wanted to tell you

1200
02:02:05,240 --> 02:02:13,120
that you can change also the overall theme. So if you like, so with the one

1201
02:02:13,120 --> 02:02:17,760
line I could change everything from like light background to dark background. You

1202
02:02:17,760 --> 02:02:19,480
You can also, there are many teams

1203
02:02:19,480 --> 02:02:24,480
that other people have created from different newspapers.

1204
02:02:25,040 --> 02:02:27,000
You can also define your own team

1205
02:02:27,000 --> 02:02:29,600
for yourself or for your research group.

1206
02:02:29,600 --> 02:02:32,400
And here's a link to a long list of themes

1207
02:02:32,400 --> 02:02:34,160
that other people have created.

1208
02:02:34,160 --> 02:02:35,000
I will not go there.

1209
02:02:35,000 --> 02:02:37,400
I only wanted you to know that this is possible.

1210
02:02:38,360 --> 02:02:41,120
I wanted to spend now the last 15 minutes of the session

1211
02:02:41,120 --> 02:02:45,800
to discuss how do I really approach plotting in real life?

1212
02:02:45,800 --> 02:02:48,200
because in real life, I don't remember anything.

1213
02:02:49,080 --> 02:02:53,040
I try to plot something every month or every few weeks

1214
02:02:53,040 --> 02:02:57,400
and then I already forgot all the details.

1215
02:02:57,400 --> 02:03:00,960
So I often start with, I go to a gallery

1216
02:03:00,960 --> 02:03:02,520
and this is not only for Vega out there,

1217
02:03:02,520 --> 02:03:04,600
this is also for Matplotlib or any library.

1218
02:03:04,600 --> 02:03:06,560
I normally go to their example library

1219
02:03:08,720 --> 02:03:12,960
and look for something that looks similar

1220
02:03:12,960 --> 02:03:14,000
to what I want to do.

1221
02:03:15,800 --> 02:03:20,080
And now you can just watch and maybe ask questions

1222
02:03:20,080 --> 02:03:24,060
and give me tips on through the notes.

1223
02:03:26,240 --> 02:03:30,540
I'm watching these notes here on a side screen.

1224
02:03:32,760 --> 02:03:35,360
And I really encourage you to then later go

1225
02:03:35,360 --> 02:03:37,320
through this exercise on your own time.

1226
02:03:38,880 --> 02:03:43,880
I think it's incredibly useful to go through these steps.

1227
02:03:43,880 --> 02:03:46,600
So now let's go through these steps together.

1228
02:03:46,600 --> 02:03:49,340
I will now take something, I will take a starting point

1229
02:03:49,340 --> 02:03:51,440
and the starting point that I will take is,

1230
02:03:55,400 --> 02:03:57,960
I just want to be close to the example.

1231
02:03:57,960 --> 02:04:01,120
Are you taking, do you have some data you want to plot

1232
02:04:01,120 --> 02:04:03,560
and then you're finding an example?

1233
02:04:03,560 --> 02:04:06,440
Are you getting the data from the example?

1234
02:04:06,440 --> 02:04:09,120
So my first, my starting point will be

1235
02:04:09,120 --> 02:04:13,580
that I take the example that is there.

1236
02:04:13,880 --> 02:04:18,880
And my first step will be to try to run the example as it is.

1237
02:04:19,440 --> 02:04:23,160
Of course, now I already forgot what I wanted to,

1238
02:04:23,160 --> 02:04:26,060
the example that I wanted to show is this slider cutoff.

1239
02:04:27,520 --> 02:04:29,160
Slider cutoff, where is it?

1240
02:04:31,560 --> 02:04:33,140
Here, this one.

1241
02:04:33,140 --> 02:04:34,640
I just want it to be close to the material.

1242
02:04:34,640 --> 02:04:38,520
So let's imagine that, hey, this looks interesting here.

1243
02:04:38,520 --> 02:04:42,040
I want to do something like they did, but with my own data.

1244
02:04:43,880 --> 02:04:50,040
But before I try anything with my own data my first step always is I first try

1245
02:04:50,040 --> 02:04:59,080
to run what they do. So here's some actually random data and they it's

1246
02:04:59,080 --> 02:05:03,160
interactive there is a slider and I can move the slider around. Is this

1247
02:05:03,160 --> 02:05:12,040
interactive and only HTML? Basically. Possibly. So I it will be interesting to

1248
02:05:12,040 --> 02:05:17,040
see if we export it to, if you save it as a SVG PNG,

1249
02:05:17,200 --> 02:05:18,360
maybe try it out.

1250
02:05:18,360 --> 02:05:20,200
I mean, maybe the learners can test it out

1251
02:05:20,200 --> 02:05:22,000
and see whether it's still interactive there.

1252
02:05:22,000 --> 02:05:27,000
I would hear probably only when we export it to HTML

1253
02:05:27,960 --> 02:05:29,040
and hopefully in the notes,

1254
02:05:29,040 --> 02:05:31,940
I have a, I describe how to export to HTML.

1255
02:05:36,240 --> 02:05:39,040
And it's also interactive in the notebook.

1256
02:05:39,040 --> 02:05:41,480
Okay, so my first step is always,

1257
02:05:41,480 --> 02:05:45,640
I want to just run what they do with their data.

1258
02:05:45,640 --> 02:05:48,640
And then my second step will be try to understand the data

1259
02:05:48,640 --> 02:05:50,080
and replace it with my own.

1260
02:05:52,420 --> 02:05:54,020
I will start a new notebook here

1261
02:05:57,000 --> 02:05:58,500
and rename it to gallery.

1262
02:06:01,600 --> 02:06:04,840
And I paste, not this thing.

1263
02:06:08,840 --> 02:06:11,120
I paste their example as is.

1264
02:06:11,480 --> 02:06:20,400
And try to run it and try to get I want to see what they see on the gallery.

1265
02:06:20,400 --> 02:06:21,680
And indeed, I do.

1266
02:06:21,680 --> 02:06:27,520
So then I'm already pretty happy.

1267
02:06:27,520 --> 02:06:32,200
What is my second step often, my second step is that, okay, there is a lot of code here,

1268
02:06:32,200 --> 02:06:35,080
I don't understand everything.

1269
02:06:35,080 --> 02:06:39,520
And I kind of squint my eyes, I don't even have to, you know, understand everything.

1270
02:06:39,520 --> 02:06:43,000
I try to focus on what we know and what we know is this part.

1271
02:06:43,920 --> 02:06:44,920
We recognize it.

1272
02:06:46,280 --> 02:06:51,280
We read a data set and here we do a point points.

1273
02:06:51,680 --> 02:06:52,840
So it's a scatterplot.

1274
02:06:55,560 --> 02:06:58,880
So we already know that this is probably the data.

1275
02:07:00,480 --> 02:07:03,680
And I don't have to understand the rest here,

1276
02:07:03,680 --> 02:07:08,480
but the second thing I will often do is I print it.

1277
02:07:09,520 --> 02:07:14,520
to see how does the data look, what is in there,

1278
02:07:16,040 --> 02:07:17,240
or how is it structured?

1279
02:07:20,200 --> 02:07:25,200
And if I print it, it's a data frame, it's a table,

1280
02:07:26,720 --> 02:07:29,120
it's a table with 100 rows,

1281
02:07:30,320 --> 02:07:32,140
and it has two columns, X and Y.

1282
02:07:33,960 --> 02:07:37,200
And X goes from zero to 99,

1283
02:07:37,200 --> 02:07:42,000
And this is the Y value is somehow random.

1284
02:07:44,360 --> 02:07:45,680
Yeah, I don't fully understand it,

1285
02:07:45,680 --> 02:07:47,680
but I don't need to because

1286
02:07:49,040 --> 02:07:51,980
now that I understand the structure of the data,

1287
02:07:53,000 --> 02:07:56,140
the next thing I will try to do is to change it,

1288
02:07:56,140 --> 02:07:58,400
replace it with my own data.

1289
02:07:58,400 --> 02:07:59,520
Okay, great, I see.

1290
02:07:59,520 --> 02:08:01,840
Yeah, so you take this, you find where the data is

1291
02:08:01,840 --> 02:08:04,600
and you start inserting your data in here.

1292
02:08:04,600 --> 02:08:06,000
Yeah, yeah.

1293
02:08:06,000 --> 02:08:07,400
And, yeah.

1294
02:08:07,400 --> 02:08:10,300
And I will now switch to,

1295
02:08:12,000 --> 02:08:13,480
so here I have a walkthrough

1296
02:08:15,320 --> 02:08:18,200
and I encourage everybody to test it out later.

1297
02:08:19,080 --> 02:08:23,120
So now that I printed the data

1298
02:08:23,120 --> 02:08:25,520
and I got a little bit of insight on what it is,

1299
02:08:28,000 --> 02:08:31,980
something I find useful is to save it to file.

1300
02:08:31,980 --> 02:08:40,900
And I will now, just for the sake of time, I will now not do it on my computer, but with

1301
02:08:40,900 --> 02:08:47,620
the help of Pandas, Pandas has a function called toCSV.

1302
02:08:47,620 --> 02:08:54,440
So I can save the table into a file, and I call it, I don't know, data.csv.

1303
02:08:54,440 --> 02:08:57,020
And then I can look at it in my editor.

1304
02:08:57,020 --> 02:09:04,020
Okay, so this is like just to understand what the data is.

1305
02:09:04,020 --> 02:09:07,980
Yeah, to understand the structure of it.

1306
02:09:07,980 --> 02:09:13,100
And then what I often do next is then, aha, now that I understand the structure, I can

1307
02:09:13,100 --> 02:09:14,100
put in my own data.

1308
02:09:14,100 --> 02:09:21,700
And this data here is now I wanted to plot for the January until October, some number

1309
02:09:21,700 --> 02:09:28,500
and this was maybe max temperature I guess.

1310
02:09:28,500 --> 02:09:42,420
And then I save it to file, I keep it on file, then I can read the data from the file.

1311
02:09:42,420 --> 02:09:49,300
And once I read the data from the file, so this is now my data CSV, I also recognize

1312
02:09:49,300 --> 02:09:51,140
is that there is now a couple of things

1313
02:09:51,140 --> 02:09:52,300
that I don't need anymore.

1314
02:09:52,300 --> 02:09:53,780
I have commented them out.

1315
02:09:53,780 --> 02:09:54,860
So I don't need this.

1316
02:09:54,860 --> 02:09:58,900
I don't need the random data.

1317
02:09:58,900 --> 02:10:00,780
I don't even need NumPy anymore here.

1318
02:10:00,780 --> 02:10:02,940
It was only used for the number,

1319
02:10:02,940 --> 02:10:04,740
for the random number generator.

1320
02:10:05,580 --> 02:10:07,980
So I would remove all the stuff that I don't need

1321
02:10:09,700 --> 02:10:11,820
and then tweak it a little bit.

1322
02:10:11,820 --> 02:10:15,500
And if you are interested in how that looks at the end,

1323
02:10:15,500 --> 02:10:18,780
I also have a notebook on where I did these steps.

1324
02:10:19,300 --> 02:10:24,300
So we can look how would the result look.

1325
02:10:24,720 --> 02:10:26,980
So here we have this original data.

1326
02:10:28,360 --> 02:10:33,360
I now write the data to file, I read it from file.

1327
02:10:36,200 --> 02:10:38,600
All this stuff I can comment out and throw away.

1328
02:10:40,440 --> 02:10:42,560
And I wanted to also adjust the slider

1329
02:10:42,560 --> 02:10:44,080
because I am looking at temperature.

1330
02:10:44,080 --> 02:10:47,140
So instead of zero to 100, maybe zero to 30.

1331
02:10:47,140 --> 02:10:49,940
And I'll define default.

1332
02:10:49,940 --> 02:10:52,940
So the default is now 15.

1333
02:10:52,940 --> 02:11:00,420
And now in my notebook, I can use the slider and look at my temperatures in maybe that was

1334
02:11:00,420 --> 02:11:01,420
Oslo.

1335
02:11:01,420 --> 02:11:09,100
So it looks like too warm for Tromso, not true.

1336
02:11:09,100 --> 02:11:12,260
So back to.

1337
02:11:12,260 --> 02:11:14,540
So let's again take a step back here.

1338
02:11:14,540 --> 02:11:17,220
So this, please try this out

1339
02:11:17,220 --> 02:11:18,740
and it doesn't have to be Vega out there.

1340
02:11:18,740 --> 02:11:23,500
Try it out with your favorite Python plotting library.

1341
02:11:26,580 --> 02:11:28,220
But going through these steps of

1342
02:11:28,220 --> 02:11:31,020
reproducing an example of somebody else,

1343
02:11:31,020 --> 02:11:33,860
maybe you find an example on the internet,

1344
02:11:33,860 --> 02:11:38,180
get an understanding of what the data is that they plot

1345
02:11:39,740 --> 02:11:42,700
and then replace it with your own data.

1346
02:11:44,540 --> 02:11:49,540
This is, I think, key to adapting examples

1347
02:11:49,540 --> 02:11:51,260
to your own projects.

1348
02:11:51,260 --> 02:11:53,340
And then you can also tweak.

1349
02:11:53,340 --> 02:11:55,100
So once I get this working,

1350
02:11:55,100 --> 02:11:57,820
I will then maybe change the font size,

1351
02:11:57,820 --> 02:11:59,720
axis annotation, axis title,

1352
02:12:01,080 --> 02:12:02,780
and then it goes into publication.

1353
02:12:03,820 --> 02:12:04,660
Yeah.

1354
02:12:07,060 --> 02:12:08,340
So now that we have a few minutes left,

1355
02:12:08,340 --> 02:12:10,440
let's also look here at questions.

1356
02:12:10,440 --> 02:12:12,320
Let me summarize key points.

1357
02:12:14,540 --> 02:12:22,660
Yeah, so hopefully, go ahead, um, go ahead, I guess, read this first.

1358
02:12:22,660 --> 02:12:30,020
Yeah, it's very important to me that the outcome of this one hour episode is not that they

1359
02:12:30,020 --> 02:12:32,540
are there is that everybody should use it.

1360
02:12:32,540 --> 02:12:39,760
It's something that I like to use, but find the library that fits your work and your style.

1361
02:12:39,760 --> 02:12:46,360
And on top of this page I list many galleries and libraries that I know about.

1362
02:12:46,360 --> 02:12:55,360
Really try to minimize the manual post-processing of the plot and try to script all steps.

1363
02:12:55,360 --> 02:13:00,720
And what that means in practice that all the steps from data to the finished plot should

1364
02:13:00,720 --> 02:13:06,840
be in your notebook or in your Python script.

1365
02:13:06,840 --> 02:13:07,840
This can be some work.

1366
02:13:07,840 --> 02:13:08,920
So this doesn't come for free.

1367
02:13:08,920 --> 02:13:10,880
It can be days of work,

1368
02:13:10,880 --> 02:13:14,120
but the nice thing is you only have to do it once.

1369
02:13:14,120 --> 02:13:16,840
And then half a year later, you get new data in

1370
02:13:16,840 --> 02:13:20,820
and you can reproduce all the plots in two minutes.

1371
02:13:22,800 --> 02:13:24,960
CSV is a really nice format.

1372
02:13:25,960 --> 02:13:28,440
It's often a good format to store data

1373
02:13:28,440 --> 02:13:29,580
that we wish to plot.

1374
02:13:31,680 --> 02:13:33,560
Of course, it has pros and cons,

1375
02:13:33,560 --> 02:13:35,400
and we remember the lesson from before

1376
02:13:35,400 --> 02:13:36,740
that discusses it nicely.

1377
02:13:38,920 --> 02:13:44,920
And Vega-Altair is all about connecting tables with visual channels.

1378
02:13:44,920 --> 02:13:48,920
Really nice library. Give it a go.

1379
02:13:48,920 --> 02:13:51,920
Give it a try.

1380
02:13:51,920 --> 02:13:53,920
Yeah.

1381
02:13:53,920 --> 02:13:55,920
Okay.

1382
02:13:55,920 --> 02:13:59,920
Should we look at the notes for some stuff?

1383
02:13:59,920 --> 02:14:00,920
Yes.

1384
02:14:00,920 --> 02:14:07,920
There was one really good question. In what situation should we not use Vega-Altair?

1385
02:14:07,920 --> 02:14:09,920
That's a good one.

1386
02:14:12,320 --> 02:14:13,040
So I have...

1387
02:14:14,480 --> 02:14:18,720
So it works really well in the notebook and in a script.

1388
02:14:18,720 --> 02:14:22,080
I think I don't know how to use it inside

1389
02:14:22,080 --> 02:14:25,600
if you write your Python code in VS Code or in Spyder.

1390
02:14:27,440 --> 02:14:29,520
It's maybe possible, I don't know how to do it,

1391
02:14:29,520 --> 02:14:32,320
so maybe then take something different.

1392
02:14:37,920 --> 02:14:43,320
Yeah, I don't know if, otherwise, so.

1393
02:14:43,320 --> 02:14:47,140
Yeah, like I can't think of many.

1394
02:14:47,140 --> 02:14:52,820
Is it good if you want complete control, like you want to define every single element, element

1395
02:14:52,820 --> 02:14:57,180
position and style yourself?

1396
02:14:57,180 --> 02:14:58,180
Is that?

1397
02:14:58,180 --> 02:14:59,180
Yes.

1398
02:14:59,180 --> 02:15:00,180
Okay, so that still is possible.

1399
02:15:00,180 --> 02:15:01,180
You can.

1400
02:15:01,180 --> 02:15:02,180
It's possible.

1401
02:15:02,180 --> 02:15:04,340
You can tweak everything, as in Matplotlib.

1402
02:15:04,340 --> 02:15:08,040
So you can have full control over all the details.

1403
02:15:08,040 --> 02:15:12,400
And as in other libraries, it is work to do that and to figure out how these things are

1404
02:15:12,400 --> 02:15:14,420
called and how to do it.

1405
02:15:14,420 --> 02:15:19,360
It has sort of library has a very extensive reference manual.

1406
02:15:19,360 --> 02:15:28,700
What what I often do when I need to tweak things is I ask a web search, I ask an AI.

1407
02:15:28,700 --> 02:15:35,020
So I paste in, here is my code, but I would like to modify the, instead of precipitation,

1408
02:15:35,020 --> 02:15:39,660
I want to have precipitation in millimeter, what do I need to modify?

1409
02:15:39,660 --> 02:15:45,180
So again, I don't remember these things, but I use the knowledge of the internet to...

1410
02:15:45,180 --> 02:15:46,180
Yeah.

1411
02:15:46,180 --> 02:15:56,220
Okay, I had at least one other question, or actually, let me scroll up and see what else.

1412
02:15:56,220 --> 02:16:04,260
it use matplotlib as a back-end? No it doesn't. So it uses, and here I'm also

1413
02:16:04,260 --> 02:16:07,700
admitting that I'm not a Vega Altair expert, so I'm really just a user, but

1414
02:16:07,700 --> 02:16:14,820
my understanding is that it uses Vega underneath. If I'm wrong, please correct

1415
02:16:14,820 --> 02:16:21,260
me. It doesn't use matplotlib as a back-end. There are other libraries, if

1416
02:16:21,260 --> 02:16:25,380
If you like the kind of high-level, nice interface,

1417
02:16:25,380 --> 02:16:27,280
there are other libraries like Seaborn,

1418
02:16:28,260 --> 02:16:30,780
which use the Mappletip underneath.

1419
02:16:30,780 --> 02:16:32,180
Okay, got it.

1420
02:16:32,180 --> 02:16:33,020
Yeah.

1421
02:16:34,140 --> 02:16:37,140
Okay, well, now it's lunchtime.

1422
02:16:37,140 --> 02:16:41,220
If we don't see many more questions here,

1423
02:16:44,180 --> 02:16:45,380
should we break?

1424
02:16:45,380 --> 02:16:49,580
And when we come back, we have, what is it?

1425
02:16:49,580 --> 02:16:50,740
We will talk about scripting.

1426
02:16:50,740 --> 02:16:54,740
we will talk about profiling and other productivity tools.

1427
02:16:54,740 --> 02:16:56,780
And I want to say, thanks, [name].

1428
02:16:56,780 --> 02:16:58,140
Thanks everybody for understanding

1429
02:16:58,140 --> 02:16:59,980
with some technical issues at the beginning.

1430
02:16:59,980 --> 02:17:02,220
Also, thanks so much for all the questions here.

1431
02:17:02,220 --> 02:17:05,020
And I will now also spend some time

1432
02:17:05,020 --> 02:17:09,620
and go through all the questions and add more answers.

1433
02:17:09,620 --> 02:17:11,460
Don't also hesitate to ask more questions

1434
02:17:11,460 --> 02:17:13,560
also later about plotting.

1435
02:17:14,660 --> 02:17:16,560
It's really one of my favorite topics.

1436
02:17:16,560 --> 02:17:24,060
Have a nice lunch break, see you in one hour, thank you, on stream, bye!

1437
02:17:46,560 --> 02:17:48,620
you

1438
02:18:16,560 --> 02:18:18,620
you

1439
02:18:46,560 --> 02:18:48,620
you

1440
02:19:16,560 --> 02:19:18,620
you

1441
02:19:46,560 --> 02:19:48,620
you

1442
02:20:16,560 --> 02:20:18,620
you

1443
02:20:46,560 --> 02:20:48,620
you

1444
02:21:16,560 --> 02:21:18,620
you

1445
02:21:46,560 --> 02:21:48,620
you

1446
02:22:16,560 --> 02:22:18,620
you

1447
02:22:46,560 --> 02:22:48,620
you

1448
02:23:16,560 --> 02:23:18,620
you

1449
02:23:46,560 --> 02:23:48,620
you

1450
02:24:16,560 --> 02:24:18,620
you

1451
02:24:46,560 --> 02:24:48,620
you

1452
02:25:16,560 --> 02:25:18,620
you

1453
02:25:46,560 --> 02:25:48,620
you

1454
02:26:16,560 --> 02:26:18,620
you

1455
02:26:46,560 --> 02:26:48,620
you

1456
02:27:16,560 --> 02:27:18,620
you

1457
02:27:46,560 --> 02:27:48,620
you

1458
02:28:16,560 --> 02:28:18,620
you

1459
02:28:46,560 --> 02:28:48,620
you

1460
02:29:16,560 --> 02:29:18,620
you

1461
02:29:46,560 --> 02:29:48,620
you

1462
02:30:16,560 --> 02:30:18,620
you

1463
02:30:46,560 --> 02:30:48,620
you

1464
02:31:16,560 --> 02:31:18,620
you

1465
02:31:46,560 --> 02:31:48,620
you

1466
02:32:16,560 --> 02:32:18,620
you

1467
02:32:46,560 --> 02:32:48,620
you

1468
02:33:16,560 --> 02:33:18,620
you

1469
02:33:46,560 --> 02:33:48,620
you

1470
02:34:16,560 --> 02:34:18,620
you

1471
02:34:46,560 --> 02:34:48,620
you

1472
02:35:16,560 --> 02:35:18,620
you

1473
02:35:46,560 --> 02:35:48,620
you

1474
02:36:16,560 --> 02:36:18,620
you

1475
02:36:46,560 --> 02:36:48,620
you

1476
02:37:16,560 --> 02:37:18,620
you

1477
02:37:46,560 --> 02:37:48,620
you

1478
02:38:16,560 --> 02:38:18,620
you

1479
02:38:46,560 --> 02:38:48,620
you

1480
02:39:16,560 --> 02:39:18,620
you

1481
02:39:46,560 --> 02:39:48,620
you

1482
02:40:16,560 --> 02:40:18,620
you

1483
02:40:46,560 --> 02:40:48,620
you

1484
02:41:16,560 --> 02:41:18,620
you

1485
02:41:46,560 --> 02:41:48,620
you

1486
02:42:16,560 --> 02:42:18,620
you

1487
02:42:46,560 --> 02:42:48,620
you

1488
02:43:16,560 --> 02:43:18,620
you

1489
02:43:46,560 --> 02:43:48,620
you

1490
02:44:16,560 --> 02:44:18,620
you

1491
02:44:46,560 --> 02:44:48,620
you

1492
02:45:16,560 --> 02:45:18,620
you

1493
02:45:46,560 --> 02:45:48,620
you

1494
02:46:16,560 --> 02:46:18,620
you

1495
02:46:46,560 --> 02:46:48,620
you

1496
02:47:16,560 --> 02:47:18,620
you

1497
02:47:46,560 --> 02:47:48,620
you

1498
02:48:16,560 --> 02:48:18,620
you

1499
02:48:46,560 --> 02:48:48,620
you

1500
02:49:16,560 --> 02:49:18,620
you

1501
02:49:46,560 --> 02:49:48,620
you

1502
02:50:16,560 --> 02:50:18,620
you

1503
02:50:46,560 --> 02:50:48,620
you

1504
02:51:16,560 --> 02:51:18,620
you

1505
02:51:46,560 --> 02:51:48,620
you

1506
02:52:16,560 --> 02:52:18,620
you

1507
02:52:46,560 --> 02:52:48,620
you

1508
02:53:16,560 --> 02:53:18,620
you

1509
02:53:46,560 --> 02:53:48,620
you

1510
02:54:16,560 --> 02:54:18,620
you

1511
02:54:46,560 --> 02:54:48,620
you

1512
02:55:16,560 --> 02:55:18,620
you

1513
02:55:46,560 --> 02:55:48,620
you

1514
02:56:16,560 --> 02:56:18,620
you

1515
02:56:46,560 --> 02:56:48,620
you

1516
02:57:16,560 --> 02:57:18,620
you

1517
02:57:46,560 --> 02:57:48,620
you

1518
02:58:16,560 --> 02:58:18,620
you

1519
02:58:46,560 --> 02:58:48,620
you

1520
02:59:16,560 --> 02:59:18,620
you

1521
02:59:46,560 --> 02:59:48,620
you

1522
03:00:16,560 --> 03:00:18,620
you

1523
03:00:46,560 --> 03:00:48,620
you

1524
03:01:16,560 --> 03:01:18,620
you

1525
03:01:46,560 --> 03:01:48,620
you

1526
03:02:16,560 --> 03:02:18,620
you

1527
03:02:46,560 --> 03:02:48,620
you

1528
03:03:16,560 --> 03:03:18,620
you

1529
03:03:46,560 --> 03:03:48,620
you

1530
03:04:16,560 --> 03:04:18,620
you

1531
03:04:46,560 --> 03:04:48,620
you

1532
03:05:16,560 --> 03:05:18,620
you

1533
03:05:46,560 --> 03:05:48,620
you

1534
03:06:16,560 --> 03:06:18,620
you

1535
03:06:46,560 --> 03:06:48,620
you

1536
03:07:16,560 --> 03:07:18,620
you

1537
03:07:46,560 --> 03:07:48,620
you

1538
03:08:16,560 --> 03:08:18,620
you

1539
03:08:46,560 --> 03:08:48,620
you

1540
03:09:16,560 --> 03:09:18,620
you

1541
03:09:46,560 --> 03:09:48,620
you

1542
03:10:16,560 --> 03:10:18,620
you

1543
03:10:46,560 --> 03:10:48,620
you

1544
03:11:16,560 --> 03:11:18,620
you

1545
03:11:46,560 --> 03:11:48,620
you

1546
03:12:16,560 --> 03:12:18,620
you

1547
03:12:46,560 --> 03:12:48,620
you

1548
03:13:16,560 --> 03:13:18,620
you

1549
03:13:46,560 --> 03:13:48,620
you

1550
03:14:16,560 --> 03:14:18,620
you

1551
03:14:46,560 --> 03:14:48,620
you

1552
03:15:16,560 --> 03:15:18,620
you

1553
03:15:46,560 --> 03:15:48,560
You

1554
03:16:16,560 --> 03:16:40,560
And we have put in a short question for you, whether you have used the command line before for anything. That's just a bit of a statistics for us to see what kind of experience you have, have had before the course. So, if you could just put in your previous usage, then that would be great.

1555
03:16:40,560 --> 03:16:45,560
put in your privacy usage, then that would be great.

1556
03:16:47,680 --> 03:16:48,840
Thanks.

1557
03:16:48,840 --> 03:16:49,680
Okay.

1558
03:16:49,680 --> 03:16:52,600
Most people are familiar with the command line.

1559
03:16:54,120 --> 03:16:55,880
Yeah, it looks very much like it.

1560
03:16:57,860 --> 03:17:02,860
So this lecture is mainly about scripts and why it's,

1561
03:17:03,980 --> 03:17:07,980
well, how to get from Jupyter Notebooks to scripts

1562
03:17:07,980 --> 03:17:16,860
why scripts are useful and how to generalize scripts so that they can be used for multiple

1563
03:17:16,860 --> 03:17:27,260
purposes or with different inputs. And we are essentially trying to show you how to get from

1564
03:17:28,780 --> 03:17:33,100
Python notebooks to repeatable Python scripts and how to streamline that process

1565
03:17:33,100 --> 03:17:39,820
and how to potentially import other Python files and how to parse input

1566
03:17:39,820 --> 03:17:43,980
commands because that's, if you want to run scripts on the command line, that's

1567
03:17:43,980 --> 03:17:51,420
what you normally have to do and why you are creating a script from this. So far

1568
03:17:51,420 --> 03:17:58,260
we have had essentially a Jupyter notebook where you were running

1569
03:17:58,260 --> 03:18:05,780
individual cells and it was quite convenient. You had the results right after, right in the notebook

1570
03:18:06,340 --> 03:18:14,900
and it let us easily experiment with the Python code and see okay what changes if we

1571
03:18:14,900 --> 03:18:21,220
change something and so on. But if we have developed something that we want to use and we

1572
03:18:21,220 --> 03:18:29,860
want to use this analysis script for multiple inputs, Jupyter Notebooks start to become a bit

1573
03:18:29,860 --> 03:18:34,340
inconvenient, because what do you do if you have multiple inputs? Do you create 10 different,

1574
03:18:34,340 --> 03:18:39,940
well, however many inputs you have, different notebooks, one for each of them? Or do you have

1575
03:18:39,940 --> 03:18:48,900
a very long notebook where you have multiple input cells? And this is essentially also the

1576
03:18:48,900 --> 03:18:55,220
problem where, yeah, which cells did I actually run before now and which cells didn't I run?

1577
03:18:55,220 --> 03:19:01,140
So you end up with something where you are, where you can easily run into,

1578
03:19:02,980 --> 03:19:08,420
I don't know if, what the inputs actually were because, yeah, I ran some cells. I'm not sure if

1579
03:19:08,420 --> 03:19:13,140
I had this thing still on and there were some other cells that I had run before from the day

1580
03:19:13,140 --> 03:19:22,900
before something and it becomes potentially yeah not reproducible. So let's assume you have

1581
03:19:22,900 --> 03:19:31,860
created 10 notebooks for the 10 different input parameters and well now you want to do that for

1582
03:19:31,860 --> 03:19:37,140
a thousand different input parameters then it becomes completely infeasible because you can't

1583
03:19:37,140 --> 03:19:44,380
well, it's a complete replication of the code a thousand times and b it's just a

1584
03:19:44,380 --> 03:19:53,100
mass of notebooks that you can't really handle anymore. So here we will show you

1585
03:19:53,100 --> 03:19:59,940
how to configure or how to change notebooks so that they can be run with

1586
03:19:59,940 --> 03:20:03,860
different parameters or rather how to convert them into scripts that can be

1587
03:20:03,860 --> 03:20:08,300
run with multiple parameters, and how you can easily

1588
03:20:08,300 --> 03:20:12,540
run these scripts also on non-interactive systems

1589
03:20:12,540 --> 03:20:13,900
like computer clusters.

1590
03:20:13,900 --> 03:20:15,500
Because that's where, essentially,

1591
03:20:15,500 --> 03:20:19,340
if you have these 1,000 runs, you will end up,

1592
03:20:19,340 --> 03:20:22,140
at least if the 1,000 things you are doing

1593
03:20:22,140 --> 03:20:26,460
is a little bit more than a few seconds of time.

1594
03:20:26,460 --> 03:20:31,620
Because it just takes too long on a normal PC.

1595
03:20:31,620 --> 03:20:33,780
Okay, so.

1596
03:20:33,780 --> 03:20:35,340
Yeah, one question.

1597
03:20:35,340 --> 03:20:37,420
Why we call it a script?

1598
03:20:37,420 --> 03:20:40,820
Because sometimes I call it a program

1599
03:20:40,820 --> 03:20:42,620
or sometimes a script,

1600
03:20:42,620 --> 03:20:47,620
but what's the difference between these two or?

1601
03:20:47,840 --> 03:20:49,900
So I would say the difference between a script

1602
03:20:49,900 --> 03:20:53,500
and a program is that a program is essentially

1603
03:20:54,740 --> 03:20:57,500
a self-contained unit.

1604
03:20:57,500 --> 03:20:59,420
So it doesn't need anything,

1605
03:20:59,420 --> 03:21:03,700
or it doesn't need anything that it doesn't kind of supply

1606
03:21:03,700 --> 03:21:05,880
when you install the program.

1607
03:21:05,880 --> 03:21:08,820
While a script is something rather smaller

1608
03:21:08,820 --> 03:21:11,500
that you normally run in some kind of

1609
03:21:11,500 --> 03:21:14,180
in so-called interpreter, Python is an interpreter.

1610
03:21:15,060 --> 03:21:18,500
So it's somewhat a smaller unit.

1611
03:21:18,500 --> 03:21:20,260
It's a bit less complex.

1612
03:21:20,260 --> 03:21:22,020
If you want to have it as a program,

1613
03:21:22,020 --> 03:21:24,820
you need to create an executable out of it.

1614
03:21:24,820 --> 03:21:30,740
and that is all stuff that takes quite a bit of effort

1615
03:21:30,740 --> 03:21:32,740
depending on the program.

1616
03:21:32,740 --> 03:21:36,660
It is entirely possible, but we are here not focusing

1617
03:21:36,660 --> 03:21:39,060
on this more software architecture

1618
03:21:39,060 --> 03:21:41,620
building side of it,

1619
03:21:41,620 --> 03:21:45,700
but really more on the how can I get my functions

1620
03:21:46,900 --> 03:21:50,620
to be run on multiple inputs.

1621
03:21:50,620 --> 03:22:03,420
And you can also somewhat say that a script could be a function, a function call, somewhat.

1622
03:22:03,420 --> 03:22:10,420
While a program is just a lot bigger, normally, and has multiple potential function calls

1623
03:22:10,420 --> 03:22:12,260
that it can run.

1624
03:22:12,260 --> 03:22:17,940
But even that can be done with scripts as well, so yeah.

1625
03:22:17,940 --> 03:22:26,220
somewhere similar but slightly slightly different. Yeah. So the

1626
03:22:26,220 --> 03:22:27,500
first thing that we

1627
03:22:29,100 --> 03:22:34,980
Yeah, yeah, go. Let's see how to convert this notebook to to the

1628
03:22:35,020 --> 03:22:35,580
script.

1629
03:22:36,100 --> 03:22:42,220
Yeah. So the first thing, there are things like paper mill that

1630
03:22:42,220 --> 03:22:55,020
can help you in using notebooks with input parameters or to parameterize notebooks. But

1631
03:22:55,820 --> 03:23:01,500
this is still something where it becomes more difficult to run this on cluster systems,

1632
03:23:01,500 --> 03:23:07,900
because it still needs Jupyter, which might be a bit of a problem. So the simplest way

1633
03:23:07,900 --> 03:23:18,700
is essentially to convert the Jupyter notebook to a Python script and Jupyter already internally

1634
03:23:18,700 --> 03:23:30,300
has a command that's called nbconvert that allows you to take a Jupyter notebook and convert it into

1635
03:23:30,300 --> 03:23:43,020
a Python file. You can also, if this doesn't work for some reason, you can use save and

1636
03:23:43,020 --> 03:23:53,660
export the notebook as a executable script that also exports the notebook as script.

1637
03:23:53,660 --> 03:24:01,220
There is one important thing that I want to mention for all these exports.

1638
03:24:01,220 --> 03:24:07,320
If you have magics included, all of these Jupiter magics that were mentioned yesterday,

1639
03:24:07,320 --> 03:24:10,240
they don't convert nicely.

1640
03:24:10,240 --> 03:24:21,000
So I would personally always remove magics before doing something and converting it into

1641
03:24:21,000 --> 03:24:31,800
Python script. So, I think we could go to the first exercise and give it like 10 minutes or so

1642
03:24:32,760 --> 03:24:38,680
to just get your first Jupyter Notebook into Python script conversion here.

1643
03:24:41,720 --> 03:24:47,560
Maybe we can show how to download this Jupyter Notebook in the

1644
03:24:47,560 --> 03:25:07,760
I would copy link here and then in file, what was it, URL and paste it in there, then open.

1645
03:25:07,760 --> 03:25:08,760
I already have that.

1646
03:25:08,760 --> 03:25:09,760
You have this.

1647
03:25:09,760 --> 03:25:13,920
I can overwrite it and then it downloaded the file here.

1648
03:25:13,920 --> 03:25:20,920
So that's relatively simple.

1649
03:25:20,920 --> 03:25:30,760
Okay, we will be, I think five minutes should be sufficient for this.

1650
03:25:30,760 --> 03:25:34,280
So let's return at 15.

1651
03:25:43,920 --> 03:25:45,980
you

1652
03:26:13,920 --> 03:26:15,980
you

1653
03:26:43,920 --> 03:26:45,980
you

1654
03:27:13,920 --> 03:27:15,980
you

1655
03:27:43,920 --> 03:27:45,980
you

1656
03:28:13,920 --> 03:28:15,980
you

1657
03:28:43,920 --> 03:28:45,980
you

1658
03:29:13,920 --> 03:29:15,980
you

1659
03:29:43,920 --> 03:29:45,980
you

1660
03:30:13,920 --> 03:30:15,980
you

1661
03:30:43,920 --> 03:30:45,980
you

1662
03:49:43,920 --> 03:49:44,920
Okay.

1663
03:49:44,920 --> 03:49:45,920
I'm going to stop sharing my screen.

1664
03:49:45,920 --> 03:49:46,920
Let me know if you guys want to share your screen.

1665
03:49:46,920 --> 03:49:47,920
Okay.

1666
03:49:47,920 --> 03:49:48,920
I will see you guys next week.

1667
03:49:48,920 --> 03:49:49,920
Bye bye.

1668
03:49:49,920 --> 03:49:50,920
Bye.

1669
03:49:50,920 --> 03:49:51,920
Bye.

1670
03:49:51,920 --> 03:49:52,920
Bye.

1671
03:49:52,920 --> 03:49:53,920
Bye.

1672
03:49:53,920 --> 03:49:54,920
Bye.

1673
03:49:54,920 --> 03:49:55,920
Bye.

1674
03:49:55,920 --> 03:49:56,920
Bye.

1675
03:49:56,920 --> 03:49:57,920
Bye.

1676
03:49:57,920 --> 03:49:58,920
Bye.

1677
03:49:58,920 --> 03:49:59,920
Bye.

1678
03:49:59,920 --> 03:50:00,920
Bye.

1679
03:50:00,920 --> 03:50:01,920
Bye.

1680
03:50:01,920 --> 03:50:02,920
Bye.

1681
03:50:02,920 --> 03:50:03,920
Bye.

1682
03:50:03,920 --> 03:50:04,920
Bye.

1683
03:50:04,920 --> 03:50:05,920
Bye.

1684
03:50:05,920 --> 03:50:06,920
Bye.

1685
03:50:06,920 --> 03:50:07,920
Bye.

1686
03:50:07,920 --> 03:50:08,920
Bye.

1687
03:50:08,920 --> 03:50:09,920
Bye.

1688
03:50:09,920 --> 03:50:10,920
Bye.

1689
03:50:10,920 --> 03:50:11,920
Bye.

1690
03:50:11,920 --> 03:50:12,920
Bye.

1691
03:50:12,920 --> 03:50:14,980
you

1692
03:50:42,920 --> 03:50:44,980
you

1693
03:51:12,920 --> 03:51:14,980
you

1694
03:51:42,920 --> 03:51:44,980
you

1695
03:52:12,920 --> 03:52:14,980
you

1696
03:52:42,920 --> 03:53:11,240
Okay, and welcome back.

1697
03:53:11,240 --> 03:53:18,760
So one option for how to do this is mentioned here in the solution, where you have a fixed

1698
03:53:18,760 --> 03:53:25,560
input and fixed output. These are positional arguments. Then you have these variable arguments

1699
03:53:25,560 --> 03:53:31,640
for the start date and the end date. You could also do something where the inputs and outputs

1700
03:53:31,640 --> 03:53:39,240
are also positional arguments, starting with a minus or minus minus, but that's essentially up to

1701
03:53:39,240 --> 03:53:48,840
what your use case is. So what was the point of doing this? The point of doing this is a you can

1702
03:53:48,840 --> 03:53:54,360
have you now automatically have a small help so that tells you okay how is this to be used.

1703
03:53:57,000 --> 03:54:02,600
You can run parts of these or actually you can run all of them.

1704
03:54:02,600 --> 03:54:10,540
So, you can run something which has a specific input that is potentially different and has

1705
03:54:10,540 --> 03:54:13,500
a certain output.

1706
03:54:13,500 --> 03:54:19,720
You can say, okay, I want a different start and end date.

1707
03:54:19,720 --> 03:54:29,740
You can, yeah, create plots for individual month or stuff and you don't for any of those

1708
03:54:29,740 --> 03:54:32,900
changes need to modify the code.

1709
03:54:32,900 --> 03:54:34,420
And that allows you, for example,

1710
03:54:34,420 --> 03:54:36,760
if you have a script that you want

1711
03:54:36,760 --> 03:54:41,860
to test different parameters on, to run exactly the same script

1712
03:54:41,860 --> 03:54:43,340
with different parameters.

1713
03:54:43,340 --> 03:54:44,920
And the good thing is, you can be sure

1714
03:54:44,920 --> 03:54:46,720
that it is actually the same script that's

1715
03:54:46,720 --> 03:54:48,580
being run on the different parameters

1716
03:54:48,580 --> 03:54:51,220
and not something else, because you're

1717
03:54:51,220 --> 03:54:55,260
running the same file without modifications.

1718
03:54:55,260 --> 03:55:06,020
We can also then start to build loops over file patterns with this,

1719
03:55:06,020 --> 03:55:12,220
where you can run this for multiple different input parameters

1720
03:55:12,220 --> 03:55:14,120
at the same time.

1721
03:55:14,120 --> 03:55:19,860
And we have made it with ArcParse a lot more robust,

1722
03:55:19,860 --> 03:55:24,860
so that user input errors are essentially grabbed

1723
03:55:24,860 --> 03:55:27,540
before the actual code is being run,

1724
03:55:27,540 --> 03:55:32,540
so that it's much clearer what the problem with the call is.

1725
03:55:36,860 --> 03:55:41,860
Now, as was somewhat mentioned in the HackMD already,

1726
03:55:46,300 --> 03:55:49,940
this of course comes with some limitations

1727
03:55:49,940 --> 03:55:54,940
because putting in this huge file name for the input data

1728
03:55:56,340 --> 03:56:00,100
or for output things is very inconvenient.

1729
03:56:00,100 --> 03:56:01,380
You don't really want to do that

1730
03:56:01,380 --> 03:56:04,540
because it's a long string that's written there.

1731
03:56:04,540 --> 03:56:06,780
However, you might have the situation

1732
03:56:06,780 --> 03:56:10,260
that you have these long configuration options

1733
03:56:10,260 --> 03:56:12,740
and that's where potentially

1734
03:56:12,740 --> 03:56:14,900
using configuration files come in.

1735
03:56:14,900 --> 03:56:18,180
And [name] mentioned that this morning,

1736
03:56:18,180 --> 03:56:23,180
that where you have kind of two main form

1737
03:56:23,260 --> 03:56:25,020
or two to three main formats,

1738
03:56:25,020 --> 03:56:28,780
how configuration files look either JSON or YAML.

1739
03:56:28,780 --> 03:56:31,580
And essentially all the configuration options

1740
03:56:31,580 --> 03:56:33,460
are then defined in there.

1741
03:56:34,580 --> 03:56:39,580
And we could also add more parameters here.

1742
03:56:39,580 --> 03:56:43,580
add more parameters here.

1743
03:56:43,580 --> 03:56:47,580
We might want to have

1744
03:56:47,580 --> 03:56:51,580
things like the color of the plot or the style of the plot

1745
03:56:51,580 --> 03:56:55,580
or something that can be changed or have specific x and y labels.

1746
03:56:55,580 --> 03:56:59,580
And if we add more and more and more input arguments

1747
03:56:59,580 --> 03:57:03,580
then the command line call that we are running here

1748
03:57:03,580 --> 03:57:07,580
gets more and more inconvenient to use.

1749
03:57:07,580 --> 03:57:14,180
So, what's often done is instead of giving 20 different input parameters, you give one

1750
03:57:14,180 --> 03:57:18,980
input parameter, which is essentially the configuration file that you want to run.

1751
03:57:18,980 --> 03:57:24,380
And you set up these configuration files.

1752
03:57:24,380 --> 03:57:32,320
And that can be done either with YAML, or with JSON, or in any other structured format

1753
03:57:32,320 --> 03:57:36,260
that's easy to use.

1754
03:57:36,260 --> 03:57:45,580
We have a small options parser that takes a simple YAML-style options file and then

1755
03:57:45,580 --> 03:57:51,420
runs it similar to ArcPars.

1756
03:57:51,420 --> 03:57:56,420
They need to define a certain type, optional arguments are derived from those values and

1757
03:57:56,420 --> 03:57:57,420
so on.

1758
03:57:57,420 --> 03:58:08,660
You would essentially end up with something where the input and output are defined in

1759
03:58:08,660 --> 03:58:16,300
a YAML file that can be then extracted.

1760
03:58:16,300 --> 03:58:18,700
Do you want to say something more to this?

1761
03:58:18,700 --> 03:58:19,700
Yes.

1762
03:58:19,700 --> 03:58:23,540
And I think you mentioned this before several minutes ago,

1763
03:58:23,540 --> 03:58:28,420
but if you each time you run the script,

1764
03:58:28,420 --> 03:58:34,580
you have to type a long in the command line.

1765
03:58:34,580 --> 03:58:38,580
And a better way that you prepare another script,

1766
03:58:38,580 --> 03:58:42,220
for example, a shell script, you copy paste everything there.

1767
03:58:42,220 --> 03:58:44,020
If you're not quite familiar with shell,

1768
03:58:44,020 --> 03:58:45,700
then put everything there.

1769
03:58:45,700 --> 03:58:57,540
and define several variables and either the input or output or the new the name for the output file

1770
03:58:57,540 --> 03:59:06,820
you can define there and using a for loop or yeah one loop or multiple loops 2k so that you can

1771
03:59:07,380 --> 03:59:14,580
automatically get the result just around this shell script the shell script we call the person

1772
03:59:14,580 --> 03:59:23,780
Python and run this. This is much more convenient for to run the code.

1773
03:59:25,380 --> 03:59:33,300
Yeah, completely agree. So especially also if you think about running potentially these kind

1774
03:59:33,300 --> 03:59:40,900
of things on a cluster and you want to put in some additional arguments, that's also an option

1775
03:59:40,900 --> 03:59:48,180
that you essentially call your scripts with some shell script that's being run that then calls the

1776
03:59:48,180 --> 03:59:55,620
submission script for the cluster and submits that script with specific parameters.

1777
03:59:56,260 --> 04:00:06,900
That's also an option. So I think we can, we do have the time to do this option parser exercise

1778
04:00:06,900 --> 04:00:12,900
here and I think it's actually a good exercise to

1779
04:00:12,900 --> 04:00:19,860
see how these yaml files are used how the how

1780
04:00:19,860 --> 04:00:23,620
these kind of configuration files can be used in a script

1781
04:00:23,620 --> 04:00:27,860
and I would give this another

1782
04:00:28,660 --> 04:00:32,740
maybe we don't have enough time yeah we need to several minutes

1783
04:00:32,740 --> 04:00:40,100
10 minutes, but then we are already in the break time. So let's see what questions we have here.

1784
04:00:43,380 --> 04:00:46,020
Maybe there's something we can discuss about this.

1785
04:00:53,140 --> 04:00:58,980
Yeah, maybe we can clarify a bit again what the input arguments here for arc powers are.

1786
04:00:58,980 --> 04:01:04,260
So, there are different types of arguments.

1787
04:01:04,260 --> 04:01:07,500
These first two, they are fixed arguments.

1788
04:01:07,500 --> 04:01:09,700
There's an input and there's an output.

1789
04:01:09,700 --> 04:01:17,500
And that's essentially the first and second non-named argument, or yeah, non-named in

1790
04:01:17,500 --> 04:01:23,300
the sense that it doesn't have a prefix like minus S minus minus start or so.

1791
04:01:23,300 --> 04:01:26,700
And these arguments have to be always provided.

1792
04:01:26,700 --> 04:01:28,980
they are non-optional.

1793
04:01:28,980 --> 04:01:33,820
And then you have these prefix arguments

1794
04:01:33,820 --> 04:01:37,460
where you can specify that what's

1795
04:01:37,460 --> 04:01:41,660
following after a minus s is the start date.

1796
04:01:41,660 --> 04:01:43,820
And that can be placed anywhere.

1797
04:01:43,820 --> 04:01:46,580
And it doesn't matter where it's being placed.

1798
04:01:46,580 --> 04:01:53,620
So you can throw around different values.

1799
04:01:53,620 --> 04:01:57,900
And depending on the settings,

1800
04:01:57,900 --> 04:01:59,020
this can have a default

1801
04:01:59,020 --> 04:02:03,060
and commonly though these arguments are optional arguments,

1802
04:02:03,060 --> 04:02:04,700
they don't necessarily have to be provided.

1803
04:02:04,700 --> 04:02:07,340
So they normally should have a default value.

1804
04:02:09,620 --> 04:02:12,620
And that can also be omitted.

1805
04:02:17,260 --> 04:02:19,180
What else do we have?

1806
04:02:23,620 --> 04:02:34,900
Yeah, I think we have already covered all this content.

1807
04:02:34,900 --> 04:02:38,660
Just trying to see.

1808
04:02:38,660 --> 04:02:48,260
There was also the question for this very long format, which we essentially heard that

1809
04:02:48,260 --> 04:02:54,940
You can set this stuff in environment variables as well and then use environment variables

1810
04:02:54,940 --> 04:03:09,260
to call the or to put it in there because it gets unreadable.

1811
04:03:09,260 --> 04:03:19,100
And then the metavar value here, a little bit further up.

1812
04:03:19,100 --> 04:03:27,100
So this is just what this value here will be looking like if it's being set so that

1813
04:03:27,100 --> 04:03:33,660
this is called n for this purpose.

1814
04:03:33,660 --> 04:03:40,660
and what it should look like in the usage description.

1815
04:03:40,660 --> 04:03:52,660
Okay, but I think this is mainly what we wanted to say for this lecture,

1816
04:03:52,660 --> 04:03:57,660
and showing you how to essentially convert into a script,

1817
04:03:57,660 --> 04:04:00,660
get some basic argument parsing set up,

1818
04:04:00,660 --> 04:04:07,220
so that you can use scripts with multiple different input arguments and I think this

1819
04:04:08,100 --> 04:04:14,980
essentially is how you get a script ready to be run on a in a non-interactive way.

1820
04:04:18,420 --> 04:04:25,060
Any other anything else from you Yonglei? No, I think it's fully covered from your aspect.

1821
04:04:25,060 --> 04:04:26,580
it.

1822
04:04:26,580 --> 04:04:27,300
OK, then.

1823
04:04:27,300 --> 04:04:30,500
It's 48, maybe.

1824
04:04:30,500 --> 04:04:34,700
Then let's do the break till 2.

1825
04:04:34,700 --> 04:04:36,900
And see you then.

1826
04:04:36,900 --> 04:04:37,400
Yeah.

1827
04:04:37,400 --> 04:04:37,900
See you.

1828
04:04:37,900 --> 04:04:38,400
Bye.

1829
04:04:38,400 --> 04:04:39,940
Bye.

1830
04:04:55,060 --> 04:04:57,120
you

1831
04:05:25,060 --> 04:05:27,120
you

1832
04:05:55,060 --> 04:05:57,120
you

1833
04:06:25,060 --> 04:06:27,120
you

1834
04:06:55,060 --> 04:06:57,120
you

1835
04:07:25,060 --> 04:07:27,120
you

1836
04:07:55,060 --> 04:07:57,120
you

1837
04:08:25,060 --> 04:08:27,120
you

1838
04:08:55,060 --> 04:08:57,120
you

1839
04:09:25,060 --> 04:09:27,120
you

1840
04:09:55,060 --> 04:09:57,120
you

1841
04:10:25,060 --> 04:10:27,120
you

1842
04:10:55,060 --> 04:10:57,120
you

1843
04:11:25,060 --> 04:11:27,120
you

1844
04:11:55,060 --> 04:11:57,120
you

1845
04:12:25,060 --> 04:12:27,120
you

1846
04:12:55,060 --> 04:12:57,120
you

1847
04:13:25,060 --> 04:13:27,120
you

1848
04:13:55,060 --> 04:13:57,120
you

1849
04:14:25,060 --> 04:14:27,120
you

1850
04:14:55,060 --> 04:14:57,120
you

1851
04:15:25,060 --> 04:15:27,120
you

1852
04:15:55,060 --> 04:16:10,260
Hello. Hello, welcome back everyone and welcome to our next lecture. In this case we will talk now

1853
04:16:10,260 --> 04:16:16,340
about profiling. So we have just had this nice lecture about scripting, so how do we turn our

1854
04:16:16,340 --> 04:16:22,740
code into Python scripts and now we will discuss the topic of how to figure out the bottlenecks

1855
04:16:22,740 --> 04:16:27,620
of this script. So whenever you care about the time your code takes to run or whenever you care

1856
04:16:27,620 --> 04:16:33,380
about how much memory it uses, you will look into profiling. But before we have a deep dive into

1857
04:16:33,380 --> 04:16:37,780
profiling, luckily I don't have to give this lecture on my own, but [name] will be joining

1858
04:16:37,780 --> 04:16:44,660
again. Hi [name]! Hi [name] and really looking forward to this really important topic. So what

1859
04:16:44,660 --> 04:16:49,300
I will do in the first part, when we talk about profiling, is I'm looking at the notes.

1860
04:16:49,300 --> 04:16:51,540
please ask a question.

1861
04:16:51,540 --> 04:16:53,780
I will try to lift them up into a discussion.

1862
04:16:55,420 --> 04:16:58,860
And we really try to keep this interactive

1863
04:16:58,860 --> 04:17:01,380
and try to keep it in like a discussion-y format.

1864
04:17:01,380 --> 04:17:04,580
And there will be one exercise block.

1865
04:17:05,500 --> 04:17:09,060
So we will discuss here for 10 minutes.

1866
04:17:09,060 --> 04:17:12,500
Then there will be a 20 minute exercise block

1867
04:17:12,500 --> 04:17:14,180
where you can try this out.

1868
04:17:14,180 --> 04:17:18,580
And then we will debrief again with a 10 minute block.

1869
04:17:19,300 --> 04:17:27,620
Exactly. Okay, so the most important question probably at the beginning is, when do I actually

1870
04:17:27,620 --> 04:17:31,780
need to care about profiling and the performance of my code? Like, is this something that I

1871
04:17:31,780 --> 04:17:36,660
need to worry about every time I create a script? Or is this only in specific cases?

1872
04:17:36,660 --> 04:17:43,620
Yeah, and this is a great question. And for maybe most scripts, we don't need to worry

1873
04:17:43,620 --> 04:17:48,860
about it you mentioned performance and performance can be two things it can be

1874
04:17:48,860 --> 04:17:58,340
speed so the time time for the script to complete and if you are happy with the

1875
04:17:58,340 --> 04:18:05,220
speed and happy with the memory consumption then no need to optimize and

1876
04:18:05,220 --> 04:18:11,580
no need to do any of any profiling so then so when we talk here in this

1877
04:18:11,580 --> 04:18:13,780
Sessionable optimizing, we really mean

1878
04:18:13,780 --> 04:18:14,820
it could be two different things.

1879
04:18:14,820 --> 04:18:16,900
It could be that it just takes too long,

1880
04:18:18,460 --> 04:18:20,860
or it means that I fill up all my memory.

1881
04:18:22,020 --> 04:18:24,860
And then we maybe need to do something about it.

1882
04:18:24,860 --> 04:18:26,300
So the next question is then,

1883
04:18:27,180 --> 04:18:29,480
or maybe before we go even into profiling,

1884
04:18:30,940 --> 04:18:32,180
should we even optimize?

1885
04:18:34,900 --> 04:18:35,980
Yeah, that's a very good question.

1886
04:18:35,980 --> 04:18:38,820
And I think as a rule of thumb,

1887
04:18:38,820 --> 04:18:41,340
I would suggest not to be too concerned

1888
04:18:41,340 --> 04:18:48,220
performance and optimization at the beginning, but focus on having a code that computes exactly

1889
04:18:48,220 --> 04:18:52,860
what you want it to do, like if your code has errors and it gets some wrong results it really

1890
04:18:52,860 --> 04:18:57,260
doesn't matter how quickly you get these wrong results. So the first priority should be to have

1891
04:18:57,260 --> 04:19:01,740
a code that does what it's supposed to do and that is readable and then if you come to the conclusion

1892
04:19:01,740 --> 04:19:05,980
that it needs to be faster or needs to use less memory then you can worry about profiling and

1893
04:19:05,980 --> 04:19:11,740
performance and all these other things. But nowadays since interpreters like Python or

1894
04:19:11,740 --> 04:19:17,340
compilers have gotten really really good it can be like super unintuitive which part of the code

1895
04:19:17,980 --> 04:19:23,980
takes the most time or uses the most memory and that's now when profiling comes in. Now there's

1896
04:19:23,980 --> 04:19:27,900
also this famous quote which is standing here, premature optimization is the root of all evil.

1897
04:19:28,460 --> 04:19:33,900
You might have heard this before and it basically means that if you've spent too much time

1898
04:19:33,900 --> 04:19:41,100
optimizing things that turn out to be not relevant, you just maneuver yourself into a dead end and

1899
04:19:41,100 --> 04:19:46,140
create problems along the way. So you would really only care about optimization once you

1900
04:19:46,700 --> 04:19:51,340
know that you need optimization and once you know which parts of the code require optimization.

1901
04:19:53,260 --> 04:19:58,460
Yeah and somebody asked in the notes what is profiling because we know we mentioned it and

1902
04:19:58,460 --> 04:20:01,860
and we will show it, you can practice it,

1903
04:20:01,860 --> 04:20:04,620
but how would you describe profiling?

1904
04:20:06,660 --> 04:20:09,180
I would describe it as such that profiling is the process

1905
04:20:09,180 --> 04:20:13,460
of figuring out which parts of the code

1906
04:20:13,460 --> 04:20:15,380
require the most resources.

1907
04:20:15,380 --> 04:20:17,820
So this can be computation, so CPU hours,

1908
04:20:17,820 --> 04:20:19,940
or it can be also memory usage.

1909
04:20:19,940 --> 04:20:22,100
So profiling is taking a script,

1910
04:20:22,100 --> 04:20:24,660
going, we discuss afterwards in detail how this is done,

1911
04:20:24,660 --> 04:20:26,660
but like taking a look at every section of the script

1912
04:20:26,660 --> 04:20:28,300
and measuring how long does it take

1913
04:20:28,300 --> 04:20:29,900
and how much memory does it use?

1914
04:20:31,900 --> 04:20:33,460
Yeah, like I like to think of it

1915
04:20:33,460 --> 04:20:34,840
and maybe it's a helpful analogy.

1916
04:20:34,840 --> 04:20:37,860
It's imagine like an X-ray for the code

1917
04:20:39,380 --> 04:20:40,900
and imagine you are like a surgeon.

1918
04:20:40,900 --> 04:20:44,980
You want to, like before a surgeon does a surgery

1919
04:20:44,980 --> 04:20:48,140
on a person, they will first put the person

1920
04:20:48,140 --> 04:20:52,380
into an X-ray MRI, which will then identify

1921
04:20:52,380 --> 04:20:53,620
where exactly is the problem

1922
04:20:53,620 --> 04:20:57,140
before we start to do the optimization code surgery.

1923
04:20:57,140 --> 04:20:59,220
So that's how I like to think of a profile.

1924
04:21:02,180 --> 04:21:05,220
Yeah, so the fastest way probably how to profile your code

1925
04:21:05,220 --> 04:21:06,760
is by measuring yourself,

1926
04:21:08,020 --> 04:21:10,460
how long these sections of the code take

1927
04:21:10,460 --> 04:21:13,780
by basically stopping the time

1928
04:21:13,780 --> 04:21:15,420
at different parts of your code.

1929
04:21:16,700 --> 04:21:18,340
This is better than nothing.

1930
04:21:18,340 --> 04:21:20,180
Of course, you will get a lot of information out of this,

1931
04:21:20,180 --> 04:21:21,780
but it has some downsides,

1932
04:21:21,780 --> 04:21:23,540
like it doesn't provide you any information

1933
04:21:23,540 --> 04:21:24,620
on the memory usage.

1934
04:21:27,140 --> 04:21:31,860
And also you have, it's a lot of manual things you need to add to your script.

1935
04:21:31,860 --> 04:21:36,100
So luckily there are tools out there that are significantly easier to use than doing this

1936
04:21:36,100 --> 04:21:43,460
manually. And the other one you've listed quite a few profilers now here in this lecture. So we

1937
04:21:43,460 --> 04:21:49,140
have profilers which focus mainly on the CPU, so the time, and we have profilers which are

1938
04:21:49,140 --> 04:21:52,500
optimal, like which are designed in such a way that they are good at measuring the

1939
04:21:52,500 --> 04:21:56,580
memory usage of the code. But there is one specifically that you recommend and this is

1940
04:21:56,580 --> 04:22:00,740
scalene, right? What does scalene do better than all these other tools that

1941
04:22:00,740 --> 04:22:04,020
people might have heard of in the past?

1942
04:22:04,900 --> 04:22:11,140
Yeah, so the reason why we added scalene here and also this is

1943
04:22:11,140 --> 04:22:15,940
the one that we will try out in a moment in in the exercise

1944
04:22:15,940 --> 04:22:20,180
is that, so I wouldn't say that it's like

1945
04:22:20,180 --> 04:22:23,140
necessarily better than the other profilers, they are all fine and they

1946
04:22:23,140 --> 04:22:26,020
have all their use case, but what I like about scalene is that it's

1947
04:22:26,020 --> 04:22:34,100
may be the the one that is easiest to use. We will be able to use it and we don't have to change the

1948
04:22:34,100 --> 04:22:41,940
code that we want to profile at all. So for some profilers you need to edit your code and add

1949
04:22:41,940 --> 04:22:48,420
certain so-called decorators or similar. With scalene we don't have to do anything. I can

1950
04:22:48,420 --> 04:22:59,820
Instead of running python myscript.py, I will run scalene myscript.py and the

1951
04:22:59,820 --> 04:23:06,380
other thing I like about scalene is that it does both CPU and memory at the

1952
04:23:06,380 --> 04:23:12,640
same time, line by line. So we will be able to see, line by line, where is the

1953
04:23:12,640 --> 04:23:17,760
bottleneck. Where's the CPU bottleneck, where is the memory bottleneck. It can

1954
04:23:17,760 --> 04:23:22,760
also analyze the GPU, it can also do GPU profiling.

1955
04:23:23,140 --> 04:23:25,780
So I think it's a good starting point.

1956
04:23:25,780 --> 04:23:28,460
Then some of the other profilers

1957
04:23:28,460 --> 04:23:32,020
that can do more details if needed.

1958
04:23:34,140 --> 04:23:39,140
It's, okay, what is the downside of scalene?

1959
04:23:39,380 --> 04:23:42,100
One possible downside, but we might discuss it or not,

1960
04:23:42,100 --> 04:23:45,640
is that it's a sampling profiler.

1961
04:23:45,640 --> 04:23:48,600
So there are sampling profilers,

1962
04:23:48,600 --> 04:23:50,040
there are tracing profilers,

1963
04:23:50,040 --> 04:23:51,240
well, not necessarily downside,

1964
04:23:51,240 --> 04:23:53,000
but both have pros and cons.

1965
04:23:54,160 --> 04:23:56,560
And sampling would mean that

1966
04:23:59,720 --> 04:24:01,440
after a certain time interval,

1967
04:24:01,440 --> 04:24:04,040
it will record where in the code it is,

1968
04:24:04,040 --> 04:24:05,640
how much memory is allocated.

1969
04:24:08,400 --> 04:24:09,640
And what does it mean in practice?

1970
04:24:09,640 --> 04:24:13,320
So what does it mean for the size of the problem

1971
04:24:13,320 --> 04:24:14,520
that we want to profile?

1972
04:24:15,640 --> 04:24:22,640
Yeah, so, when you profile your code, you typically want to use a code that represents

1973
04:24:22,640 --> 04:24:23,640
your real-world problem.

1974
04:24:23,640 --> 04:24:26,720
Like, typically, it should be something that is similar to the actual code that you want

1975
04:24:26,720 --> 04:24:27,720
to run in the long run.

1976
04:24:27,720 --> 04:24:33,760
Now, I can give an example, during my PhD, I was running a lot of computational simulations,

1977
04:24:33,760 --> 04:24:39,600
which took multiple hours on a supercomputer, and at the beginning, I wanted to have a

1978
04:24:39,600 --> 04:24:44,000
shorter version of the code, so I wouldn't buy that many resources for the profiling,

1979
04:24:44,000 --> 04:24:47,560
And then it turned out that most of my time was going on initializing the simulation and

1980
04:24:47,560 --> 04:24:49,360
not actually running the simulation.

1981
04:24:49,360 --> 04:24:56,120
So when I was profiling the code, it was telling me, oh yeah, you're setting up a simulation

1982
04:24:56,120 --> 04:25:00,520
takes so much time and you should really focus on optimizing this, which of course was the

1983
04:25:00,520 --> 04:25:05,000
completely wrong conclusion since what we actually care is the computational part, which

1984
04:25:05,000 --> 04:25:08,880
a real simulation takes much longer than setting up a simulation.

1985
04:25:08,880 --> 04:25:12,560
it should be representative for the problem that we try to solve at hand.

1986
04:25:14,960 --> 04:25:24,400
Okay, so we now slowly go to our exercise. In this case, we will now use scalene to

1987
04:25:25,760 --> 04:25:33,200
count, or we have a Python script that is shown further down here, which takes an input file,

1988
04:25:33,200 --> 04:25:40,880
which is a text file in this case, and counts the number of unique words in this text file.

1989
04:25:40,880 --> 04:25:45,840
The instructions on how to download it are presented above. So you can download it from

1990
04:25:45,840 --> 04:25:51,920
this link and then you can run scalene inside your terminal as shown here. And

1991
04:25:54,080 --> 04:25:59,280
you can see here there are three different implementations for counting the number of

1992
04:25:59,280 --> 04:26:04,240
unique words and before you actually do the profiling maybe have a look at the code and

1993
04:26:04,240 --> 04:26:09,280
have a guess or like think of which of these implementations takes the most time and takes

1994
04:26:09,280 --> 04:26:13,520
the most memory because you might be surprised when you actually do the profiling sometimes

1995
04:26:13,520 --> 04:26:21,440
it can be really unintuitive. Okay so I think with that we will now have a 20-minute

1996
04:26:21,440 --> 04:26:28,760
exercise session and we'll be back then and run Scalene here on the stream and

1997
04:26:28,760 --> 04:26:35,200
discuss the results together. Okay, see you in 20 minutes. Bye!

1998
04:26:51,440 --> 04:26:53,500
you

1999
04:27:21,440 --> 04:27:23,500
you

2000
04:27:51,440 --> 04:27:53,500
you

2001
04:28:21,440 --> 04:28:23,500
you

2002
04:28:51,440 --> 04:28:53,500
you

2003
04:29:21,440 --> 04:29:23,500
you

2004
04:29:51,440 --> 04:29:53,500
you

2005
04:30:21,440 --> 04:30:23,500
you

2006
04:30:51,440 --> 04:30:53,500
you

2007
04:31:21,440 --> 04:31:23,500
you

2008
04:31:51,440 --> 04:31:53,500
you

2009
04:32:21,440 --> 04:32:23,500
you

2010
04:32:51,440 --> 04:32:53,500
you

2011
04:33:21,440 --> 04:33:23,500
you

2012
04:33:51,440 --> 04:33:53,500
you

2013
04:34:21,440 --> 04:34:23,500
you

2014
04:34:51,440 --> 04:34:53,500
you

2015
04:35:21,440 --> 04:35:23,500
you

2016
04:35:51,440 --> 04:35:53,500
you

2017
04:36:21,440 --> 04:36:23,500
you

2018
04:36:51,440 --> 04:36:53,500
you

2019
04:37:21,440 --> 04:37:23,500
you

2020
04:37:51,440 --> 04:37:53,500
you

2021
04:38:21,440 --> 04:38:23,500
you

2022
04:38:51,440 --> 04:38:53,500
you

2023
04:39:21,440 --> 04:39:23,500
you

2024
04:39:51,440 --> 04:39:53,500
you

2025
04:40:21,440 --> 04:40:23,500
you

2026
04:40:51,440 --> 04:40:53,500
you

2027
04:41:21,440 --> 04:41:23,500
you

2028
04:41:51,440 --> 04:41:53,500
you

2029
04:42:21,440 --> 04:42:23,500
you

2030
04:42:51,440 --> 04:42:53,500
you

2031
04:43:21,440 --> 04:43:23,500
you

2032
04:43:51,440 --> 04:43:53,500
you

2033
04:44:21,440 --> 04:44:23,500
you

2034
04:44:51,440 --> 04:44:53,500
you

2035
04:45:21,440 --> 04:45:23,500
you

2036
04:45:51,440 --> 04:46:03,080
Okay, welcome back. We saw there were quite some interesting questions in the HedgeShop

2037
04:46:03,080 --> 04:46:13,080
document. One was about R, so a different language. So, we should highlight that profiling

2038
04:46:13,080 --> 04:46:17,200
code is really nothing Python specific. It's something that exists for pretty much any

2039
04:46:17,200 --> 04:46:23,520
language you can find out that, whether that's R or Julia or C++ or whatever, like there are always

2040
04:46:23,520 --> 04:46:28,960
ways how you can do this type of profiling. Scalene is Python specific, but you will find very

2041
04:46:28,960 --> 04:46:34,640
similar tools in other languages. So we really want to focus here on the concepts so that you

2042
04:46:34,640 --> 04:46:40,880
can apply them in whatever language you want. There were also some other technical difficulties.

2043
04:46:40,880 --> 04:46:49,920
Shall we quickly comment on this or shall we jump straight to the result of the profiling?

2044
04:46:49,920 --> 04:46:55,240
Yeah, maybe just a quick comment that please don't get discouraged if you hit technical

2045
04:46:55,240 --> 04:46:56,240
issues.

2046
04:46:56,240 --> 04:47:01,360
Really, our goal was that you all know that this is a tool that exists.

2047
04:47:01,360 --> 04:47:06,440
And it wasn't a super easy exercise because we asked people to also download a file, rename

2048
04:47:06,440 --> 04:47:15,800
file. Yeah, so a couple of steps. But maybe it will also help. Let's show how it looks

2049
04:47:17,000 --> 04:47:24,200
when it's working. So I spin up my terminal and I have here the book.txt file, which I downloaded

2050
04:47:24,200 --> 04:47:29,960
earlier, and the example.py script. So this is the code that is also shown here in the instructions.

2051
04:47:29,960 --> 04:47:34,960
So now I'm going to run scalene.example.py like this.

2052
04:47:37,160 --> 04:47:39,440
This will take a few seconds,

2053
04:47:39,440 --> 04:47:42,760
and then it will spin up a page

2054
04:47:42,760 --> 04:47:45,480
where it shows us the results of the profiling.

2055
04:47:45,480 --> 04:47:46,880
That opens it in the wrong browser,

2056
04:47:46,880 --> 04:47:48,360
so I drag it over here.

2057
04:47:48,360 --> 04:47:50,080
Okay, here we go.

2058
04:47:50,080 --> 04:47:51,400
So here we see the results,

2059
04:47:51,400 --> 04:47:53,480
and you can now, by default,

2060
04:47:53,480 --> 04:47:55,000
it only shows you a number of lines,

2061
04:47:55,000 --> 04:47:56,000
but if you want to see all of them,

2062
04:47:56,000 --> 04:47:57,200
you can here tick this box,

2063
04:47:57,200 --> 04:47:59,320
and then you can see the whole script.

2064
04:47:59,320 --> 04:48:02,680
So I think the script is short enough that we can do this.

2065
04:48:02,680 --> 04:48:04,720
Okay, so let's have a look at the results.

2066
04:48:08,080 --> 04:48:10,040
What should we focus on at the beginning?

2067
04:48:10,040 --> 04:48:10,960
So how do you look at this?

2068
04:48:10,960 --> 04:48:12,480
Like, how do you read this thing?

2069
04:48:12,480 --> 04:48:17,480
So on the right side of the screen, I see our code.

2070
04:48:19,080 --> 04:48:21,120
So this is a line-by-line profiler.

2071
04:48:21,120 --> 04:48:23,620
It will give us a profile with a line-by-line.

2072
04:48:24,680 --> 04:48:27,240
And then there are lots of symbols,

2073
04:48:27,240 --> 04:48:31,600
But what are the things that you look at next?

2074
04:48:31,600 --> 04:48:35,680
Yeah, so depending on whether I'm interested in the time

2075
04:48:35,680 --> 04:48:37,840
it takes to run a program or the memory,

2076
04:48:37,840 --> 04:48:39,720
I will focus on these two things.

2077
04:48:39,720 --> 04:48:41,920
So the first column here gives us

2078
04:48:41,920 --> 04:48:45,280
the time that is taken by each role in this program.

2079
04:48:45,280 --> 04:48:48,040
And we can clearly see that the culprit in this program

2080
04:48:48,040 --> 04:48:51,960
is the second implementation of counting words.

2081
04:48:51,960 --> 04:48:55,920
So we can see that more than half of the time

2082
04:48:55,920 --> 04:48:57,840
is here taken by this line here.

2083
04:48:59,680 --> 04:49:02,520
Yeah, and I think what happens

2084
04:49:02,520 --> 04:49:03,440
if you scroll all the way down,

2085
04:49:03,440 --> 04:49:06,280
do you also see the summary?

2086
04:49:06,280 --> 04:49:11,280
Yeah, so then I know that that function takes most time.

2087
04:49:12,640 --> 04:49:14,880
And then if I want to know which line in that function,

2088
04:49:14,880 --> 04:49:17,640
then it's the line 21.

2089
04:49:19,760 --> 04:49:23,520
And maybe we can even help answering why is it so,

2090
04:49:23,520 --> 04:49:26,520
Like why does the code spend the most time in line 21?

2091
04:49:28,080 --> 04:49:30,640
So if we compare, sorry, do you?

2092
04:49:31,520 --> 04:49:32,640
No, go ahead.

2093
04:49:32,640 --> 04:49:36,960
Okay, so if we compare like our best implementation here,

2094
04:49:36,960 --> 04:49:39,400
which is the third function to the second one,

2095
04:49:39,400 --> 04:49:41,480
we can see the main difference here is that we use here

2096
04:49:41,480 --> 04:49:43,920
a list to store our values.

2097
04:49:43,920 --> 04:49:45,920
And in the third function, we use a set.

2098
04:49:47,040 --> 04:49:49,400
So in the list, we have all the values

2099
04:49:49,400 --> 04:49:53,000
which are then saved one after one.

2100
04:49:53,000 --> 04:49:54,600
So this if statement that we have here

2101
04:49:54,600 --> 04:49:58,120
is going for every single element in this list

2102
04:49:58,120 --> 04:50:00,280
and checking whether the new word

2103
04:50:00,280 --> 04:50:02,280
is already existing or not in this list.

2104
04:50:02,280 --> 04:50:04,480
And if it's not, then we append the list.

2105
04:50:04,480 --> 04:50:07,880
But this is arguably a very bad implementation

2106
04:50:07,880 --> 04:50:09,960
since it requires us to go for the list

2107
04:50:09,960 --> 04:50:11,840
for every new word that we find.

2108
04:50:11,840 --> 04:50:14,220
And that's why it takes so much time.

2109
04:50:14,220 --> 04:50:17,040
Now the third function here is significantly faster

2110
04:50:17,040 --> 04:50:19,920
since we use a set, which is a different data type.

2111
04:50:19,920 --> 04:50:24,360
since it doesn't store every single element one by one,

2112
04:50:24,360 --> 04:50:26,720
but it's using something called hashing.

2113
04:50:26,720 --> 04:50:29,080
So it uses a fancy function,

2114
04:50:29,080 --> 04:50:32,140
which gives every element a hash.

2115
04:50:32,140 --> 04:50:34,440
So that's a specific identifier,

2116
04:50:34,440 --> 04:50:36,200
which is really easy to compute.

2117
04:50:36,200 --> 04:50:38,280
And then it can look up in the set

2118
04:50:38,280 --> 04:50:40,040
what it's already done or not.

2119
04:50:40,040 --> 04:50:44,160
But it's kind of a very, very fast explanation.

2120
04:50:44,160 --> 04:50:49,160
We can also see if we take a look at the memory footprint

2121
04:50:50,860 --> 04:50:54,080
that the first function here takes a lot,

2122
04:50:54,080 --> 04:50:55,880
much more memory than the other two.

2123
04:50:58,400 --> 04:51:01,240
And this is because we load in the whole text file

2124
04:51:01,240 --> 04:51:05,760
and then perform this regex for here on the whole,

2125
04:51:07,640 --> 04:51:09,000
the whole text file at once,

2126
04:51:09,000 --> 04:51:10,520
whereas in the later ones,

2127
04:51:10,520 --> 04:51:15,520
we then actually go, we have this four-open addition

2128
04:51:15,880 --> 04:51:18,400
where we can go word by word through the elements,

2129
04:51:19,640 --> 04:51:21,440
which then, sorry, here, line by line,

2130
04:51:21,440 --> 04:51:26,200
so we don't load the whole dataset at once into memory,

2131
04:51:26,200 --> 04:51:27,760
but we do it line by line,

2132
04:51:27,760 --> 04:51:31,140
which then results in a lower memory footprint.

2133
04:51:36,360 --> 04:51:39,260
Is this a sufficient explanation, or did I miss something?

2134
04:51:40,520 --> 04:51:43,160
No, I think this is really good.

2135
04:51:43,160 --> 04:51:47,720
So what we really wanted to show all of you is that,

2136
04:51:47,720 --> 04:51:50,080
yeah, we have a tool here that we can really identify

2137
04:51:50,080 --> 04:51:54,520
the line where most memory or most CPU is spent.

2138
04:51:55,440 --> 04:51:59,680
And that is also good to read a little bit

2139
04:51:59,680 --> 04:52:01,880
about different data types,

2140
04:52:01,880 --> 04:52:03,840
I mean, data containers like sets and lists

2141
04:52:03,840 --> 04:52:05,280
because they have pros and cons.

2142
04:52:05,280 --> 04:52:09,360
And here we have seen one disadvantage of lists.

2143
04:52:10,520 --> 04:52:15,160
And the other take home message that we wanted to convey

2144
04:52:15,160 --> 04:52:19,960
is that when processing big data files or big texts,

2145
04:52:20,960 --> 04:52:23,320
it can be good to go, I don't know, line by line

2146
04:52:23,320 --> 04:52:27,840
or in batches instead of reading the entire thing.

2147
04:52:27,840 --> 04:52:29,780
Because the function number one,

2148
04:52:31,280 --> 04:52:33,440
if we go to larger and larger books,

2149
04:52:34,720 --> 04:52:36,620
it will consume more and more memory.

2150
04:52:36,620 --> 04:52:44,620
One additional thing that we get from scalene is the time which is used inside of python and then

2151
04:52:44,620 --> 04:52:49,500
other libraries and how much time is then used up by the system that we run the code on and the

2152
04:52:49,500 --> 04:52:56,940
same is here for the memory. So the python section here refers to the time that is actually taken by

2153
04:52:56,940 --> 04:53:03,180
the python code itself and the native one is then by code that python calls. So if you remember from

2154
04:53:03,180 --> 04:53:08,860
the NumPy lecture, for instance, we've learned that the one reason why NumPy is so fast is because

2155
04:53:08,860 --> 04:53:14,780
it calls functions that are actually implemented in C and Fortran under the hood, so it's not running

2156
04:53:14,780 --> 04:53:20,380
native Python code, and this will then show up in Scalene here as the native part. And then the

2157
04:53:20,380 --> 04:53:24,780
system part is the one which is just taking time from the operating system, so there's always

2158
04:53:24,780 --> 04:53:29,340
something running in the background which then has contribution to the overall time.

2159
04:53:29,340 --> 04:53:36,140
And also we have here the timeline of the memory, so we can see here that almost all of the memory

2160
04:53:36,140 --> 04:53:40,300
here was used up at the beginning of the program, which makes sense since that's when we, at the

2161
04:53:40,300 --> 04:53:46,220
beginning, when we call the first function, and then afterwards the second and the third uses

2162
04:53:46,220 --> 04:53:52,460
much less memory, so we can also see here in this timeline that afterwards the memory footprint is

2163
04:53:52,460 --> 04:53:56,380
negligible compared to the first one. So there's a lot of information that scaling provides.

2164
04:53:56,380 --> 04:54:03,380
Is there anything else that you look at typically around the one?

2165
04:54:03,380 --> 04:54:16,020
Not really, where is the bottleneck, but also like the profile of the memory allocations.

2166
04:54:16,020 --> 04:54:21,580
Because the bottleneck will show me like the high memory watermark, but it can be interesting

2167
04:54:21,580 --> 04:54:27,180
to know like is everything allocated at the beginning and then nothing later.

2168
04:54:27,180 --> 04:54:32,360
If it's like that it can sometimes mean that I should split up the script into two scripts,

2169
04:54:32,360 --> 04:54:35,560
one that needs a lot of memory and then the rest of the script that needs no memory at

2170
04:54:35,560 --> 04:54:38,560
all.

2171
04:54:38,560 --> 04:54:43,960
I'm also looking at the questions and some people don't see the same result as we do

2172
04:54:43,960 --> 04:54:50,080
and I wonder whether it's different defaults, different versions.

2173
04:54:50,080 --> 04:54:52,800
and it might require some extra options.

2174
04:54:56,200 --> 04:54:58,280
Yeah, so if you open the terminal

2175
04:54:58,280 --> 04:55:01,340
and you type in your name on its own,

2176
04:55:01,340 --> 04:55:02,760
it will give you a lot of information

2177
04:55:02,760 --> 04:55:05,380
with a lot of flags that you can use.

2178
04:55:05,380 --> 04:55:07,040
And you might need to use some of these flags

2179
04:55:07,040 --> 04:55:10,320
since you might have a different version

2180
04:55:10,320 --> 04:55:12,240
and then you can specify all these things here.

2181
04:55:12,240 --> 04:55:14,280
So you can specify what kind of output format you want

2182
04:55:14,280 --> 04:55:17,780
where you want it to be printed out to the command line.

2183
04:55:17,780 --> 04:55:20,420
And it also, you can also specify

2184
04:55:20,420 --> 04:55:21,700
whether you only want to look at memory

2185
04:55:21,700 --> 04:55:24,300
or whether you want to take the memory part off,

2186
04:55:24,300 --> 04:55:27,400
what kind of threshold you want for the memory footprint.

2187
04:55:27,400 --> 04:55:29,020
So if you have a piece of code

2188
04:55:29,020 --> 04:55:32,300
which doesn't show any memory usage,

2189
04:55:32,300 --> 04:55:33,900
it might be that the default threshold

2190
04:55:33,900 --> 04:55:36,460
for scaling is too high.

2191
04:55:36,460 --> 04:55:38,360
So you might want to lower that.

2192
04:55:39,420 --> 04:55:41,820
We don't have time to go through all these options here,

2193
04:55:41,820 --> 04:55:45,580
but if you want to learn more about it,

2194
04:55:45,580 --> 04:55:47,140
you can find, of course, a lot online,

2195
04:55:47,140 --> 04:55:51,460
also here in the command line itself, you can find a lot of information about these flags.

2196
04:55:52,580 --> 04:55:55,460
So I'm quite sure that almost all of the technical difficulties

2197
04:55:55,460 --> 04:55:58,660
that are shown here can be solved by using the right flags.

2198
04:56:02,500 --> 04:56:07,460
Okay, is there something else to say? We are at the end of our slot, 40 minutes.

2199
04:56:07,460 --> 04:56:10,860
let's move on to the next.

2200
04:56:10,860 --> 04:56:15,140
Yeah, let's, the remaining 20 minutes in this,

2201
04:56:15,140 --> 04:56:18,900
for today we will spend with productivity tools.

2202
04:56:19,940 --> 04:56:22,420
Maybe for this I will take over the screen.

2203
04:56:22,420 --> 04:56:24,860
Yeah, so I stop sharing.

2204
04:56:24,860 --> 04:56:29,260
We might again then need to adjust the screen crop.

2205
04:56:29,260 --> 04:56:30,240
Let's see.

2206
04:56:30,240 --> 04:56:46,240
This is the screen, and I will just verify how that looks.

2207
04:56:46,240 --> 04:56:50,240
Okay, I'm switching to it.

2208
04:56:50,240 --> 04:56:52,240
Yeah, looks good.

2209
04:56:52,240 --> 04:56:58,240
Because we are using a little workaround, but that looks pretty good.

2210
04:56:58,240 --> 04:57:04,240
So we will leave profiling, there is a lot more to say, of course, and a lot more to ask, and please do ask.

2211
04:57:04,240 --> 04:57:08,240
Now, 20 minutes or less on productivity tools.

2212
04:57:08,240 --> 04:57:12,240
We also want to leave room for feedback.

2213
04:57:12,240 --> 04:57:18,240
Productivity tools, this will only be a demo and a discussion.

2214
04:57:18,240 --> 04:57:27,240
I wanted to mention a few tools that I like to use or I see people using that help me be more productive.

2215
04:57:27,240 --> 04:57:35,180
they helped me focusing more on the Python part and less worrying about the

2216
04:57:35,180 --> 04:57:41,820
typesetting let's say I mean the like auto formatting for instance so it's

2217
04:57:41,820 --> 04:57:48,980
about consistent styling so format of the code but also about spotting

2218
04:57:48,980 --> 04:57:54,340
problems sometimes small problems and sometimes they are called like lint like

2219
04:57:54,340 --> 04:58:00,820
when you take laundry out of the dryer. So little particles hanging together, small issues

2220
04:58:02,260 --> 04:58:06,980
that are maybe hard to spot. But now we have tools that can help us spotting them.

2221
04:58:10,100 --> 04:58:15,700
So they are called linters. And again, there are many, many of these tools.

2222
04:58:15,700 --> 04:58:25,200
Here we list the few that we know about.

2223
04:58:25,200 --> 04:58:32,880
The tool that I will demonstrate is, I will demonstrate only one of those, it's Ruff.

2224
04:58:32,880 --> 04:58:40,440
It's part of your software environment, so you can also test it out in your Conda environment,

2225
04:58:40,440 --> 04:58:45,440
in your conda prompt.

2226
04:58:47,760 --> 04:58:50,860
The reason why I chose to demonstrate rough

2227
04:58:50,860 --> 04:58:55,100
and not the other tools is that it's a tool that can do both.

2228
04:58:55,100 --> 04:58:59,040
It can do both linting.

2229
04:58:59,040 --> 04:59:01,760
It can check for small problems,

2230
04:59:01,760 --> 04:59:04,160
but it can also automatically format the code.

2231
04:59:04,160 --> 04:59:14,240
and you can also configure these tools so they have good defaults but you can

2232
04:59:14,240 --> 04:59:20,000
configure what what they should detect what they should ignore how you want to

2233
04:59:20,000 --> 04:59:29,960
format your code let me demonstrate it so for this I created an example which is

2234
04:59:29,960 --> 04:59:38,020
here and it's somehow maybe familiar it's one of these I took one of the

2235
04:59:38,020 --> 04:59:44,240
functions from our previous episodes from the profiling episode and I

2236
04:59:44,240 --> 04:59:50,600
introduced three problems in there they are highlighted with yellow background

2237
04:59:50,600 --> 04:59:57,440
one problem is that I import a library that I never use and that can happen

2238
04:59:57,440 --> 05:00:01,200
because sometimes you import something, you use it, and later you improve the code

2239
05:00:01,200 --> 05:00:04,080
and you end up not using it. But now I forgot to remove this.

2240
05:00:06,960 --> 05:00:10,000
I also forgot there is a forgotten variable there that is unused.

2241
05:00:11,440 --> 05:00:15,440
Not a big deal, but it complicates the code and maybe it will confuse the next person.

2242
05:00:16,720 --> 05:00:21,360
Here the problem is that there is a parenthesis too much.

2243
05:00:21,360 --> 05:00:32,780
And now I will try to find these issues with the tool rough.

2244
05:00:32,780 --> 05:00:37,180
Here is the example code on my computer and you can type rough.

2245
05:00:37,180 --> 05:00:40,540
So this is something you can try now or later.

2246
05:00:40,540 --> 05:00:46,200
You can type rough check and the code.

2247
05:00:46,200 --> 05:00:49,980
Like this, but you can also leave out the file and it will check all the Python files

2248
05:00:49,980 --> 05:00:53,140
that it finds in the present directory.

2249
05:00:59,220 --> 05:01:01,020
And in the meantime, I also see the question

2250
05:01:01,020 --> 05:01:04,900
that many IDEs, integrated development environments,

2251
05:01:04,900 --> 05:01:06,740
offer some form of linting and auto-formatting,

2252
05:01:06,740 --> 05:01:09,180
and yes, they do, and I will comment more on that.

2253
05:01:11,060 --> 05:01:14,660
And indeed, running this,

2254
05:01:14,660 --> 05:01:18,380
it found that in line 10, there is something funny here.

2255
05:01:18,380 --> 05:01:21,660
So there was this parenthesis too much.

2256
05:01:21,660 --> 05:01:23,780
I will now open up the...

2257
05:01:23,780 --> 05:01:26,940
So this vi is my editor here that I can edit the file.

2258
05:01:26,940 --> 05:01:35,380
I will open it up and remove this wrong extra parenthesis here.

2259
05:01:35,380 --> 05:01:41,560
I will save and exit and run rough check again.

2260
05:01:41,560 --> 05:01:46,740
And now it finds these two other problems.

2261
05:01:46,740 --> 05:01:58,420
imported but never used, this variable is unused, can be removed. So that's neat.

2262
05:01:58,420 --> 05:02:12,680
It can help me declutter code. The same tool can also be used for auto-formatting code.

2263
05:02:12,680 --> 05:02:17,680
So here I took this function and I removed some spaces,

2264
05:02:18,600 --> 05:02:19,480
added some spaces.

2265
05:02:19,480 --> 05:02:22,080
So this code still works, it runs.

2266
05:02:22,080 --> 05:02:27,080
So Python doesn't mind, but it makes it now easier.

2267
05:02:27,440 --> 05:02:29,740
It makes it harder for me to read it, actually.

2268
05:02:32,560 --> 05:02:37,400
And with, well, let me do that.

2269
05:02:37,400 --> 05:02:41,520
I will copy this to my computer.

2270
05:02:42,680 --> 05:02:50,240
And paste it in here, this badly formatted one.

2271
05:02:50,240 --> 05:02:55,560
And the way I could now auto-format it is rough-format again, either with the file name

2272
05:02:55,560 --> 05:03:00,000
or please auto-format all the files.

2273
05:03:00,000 --> 05:03:09,240
And what you then get is, it will automatically format it according to recommended Python

2274
05:03:09,240 --> 05:03:12,960
style guide, which you can then configure.

2275
05:03:12,960 --> 05:03:15,960
So if you don't, if you really don't like four spaces

2276
05:03:15,960 --> 05:03:18,520
and you really want to have two spaces instead of four,

2277
05:03:18,520 --> 05:03:20,280
these are things you can configure.

2278
05:03:24,400 --> 05:03:26,040
There is a question in the chat.

2279
05:03:26,040 --> 05:03:30,440
What, what, can you define what is auto-formatting?

2280
05:03:30,440 --> 05:03:32,920
So maybe it's a quick kind of definition.

2281
05:03:32,920 --> 05:03:36,320
Yeah, so what it means is that I want it,

2282
05:03:36,320 --> 05:03:41,320
I want automatically to change the spaces

2283
05:03:42,760 --> 05:03:47,760
and line breaks to reformat it automatically, not by hand.

2284
05:03:52,040 --> 05:03:53,440
So I don't want to go here.

2285
05:03:53,440 --> 05:03:56,120
If you want to do it manually, it would look like this.

2286
05:04:01,480 --> 05:04:03,240
So manual formatting would look like that.

2287
05:04:03,240 --> 05:04:06,120
Like, oh yeah, there's too much space here.

2288
05:04:06,120 --> 05:04:10,040
This should go, this is manual formatting

2289
05:04:10,040 --> 05:04:12,480
and I don't want to do this manually.

2290
05:04:12,480 --> 05:04:15,440
So then I have a tool that will just do it in one shot.

2291
05:04:16,880 --> 05:04:21,880
You can even configure your editor to do that for you.

2292
05:04:26,600 --> 05:04:30,160
Some people let it format every time they save the file

2293
05:04:31,760 --> 05:04:34,040
and this has pros and cons, we can discuss them.

2294
05:04:34,040 --> 05:04:36,400
For instance, I have a key here on my keyboard

2295
05:04:36,400 --> 05:04:37,800
that I've configured.

2296
05:04:37,800 --> 05:04:39,320
If I press the key,

2297
05:04:39,320 --> 05:04:42,440
it will automatically format it for me.

2298
05:04:43,580 --> 05:04:45,560
This time with a different auto formatter.

2299
05:04:45,560 --> 05:04:50,560
So black is another popular auto formatter for Python.

2300
05:04:58,120 --> 05:04:58,960
Good.

2301
05:05:01,400 --> 05:05:02,720
There is more.

2302
05:05:02,720 --> 05:05:06,520
I will not demonstrate these because I admitted personally

2303
05:05:06,520 --> 05:05:09,360
I don't use them, but I want you to know that they exist.

2304
05:05:09,360 --> 05:05:11,400
So they are also tools that can check.

2305
05:05:12,680 --> 05:05:15,520
For instance, if you have type annotations

2306
05:05:16,440 --> 05:05:18,140
like this function expects a string

2307
05:05:18,140 --> 05:05:19,480
and it returns an integer.

2308
05:05:21,360 --> 05:05:24,480
There are tools that can help you check,

2309
05:05:24,480 --> 05:05:29,480
they can do analysis on types and help identify problems.

2310
05:05:29,480 --> 05:05:37,960
problems. You can integrate these with your editor. Many environments come with this already,

2311
05:05:37,960 --> 05:05:43,560
batteries included, but you can configure your editor to do formatting, linting for you.

2312
05:05:45,080 --> 05:05:53,000
Some editors then kind of underline problems like typos in a word document.

2313
05:05:53,000 --> 05:05:58,000
and you can also do this in your Jupyter Notebook.

2314
05:05:58,400 --> 05:06:00,160
So if there are three packages,

2315
05:06:00,160 --> 05:06:03,200
if you have them in your software environment,

2316
05:06:06,000 --> 05:06:09,600
then in your Notebook, there is an extra button

2317
05:06:09,600 --> 05:06:13,020
that you can press and it will auto-format your Python code.

2318
05:06:17,280 --> 05:06:18,680
If you use version control,

2319
05:06:18,680 --> 05:06:21,600
and version control is a way of

2320
05:06:23,000 --> 05:06:26,300
saving snapshots of the code as we develop.

2321
05:06:26,300 --> 05:06:29,500
You can even tell your version control

2322
05:06:29,500 --> 05:06:33,380
to please run these checks before I archive a new version.

2323
05:06:36,620 --> 05:06:38,280
Just looking at the questions.

2324
05:06:48,260 --> 05:06:49,540
But also they get good answers.

2325
05:06:49,540 --> 05:06:51,140
I might return to some of those.

2326
05:06:53,000 --> 05:07:03,880
So, I want to mention one more thing now that is AI-assisted coding, but before I do that,

2327
05:07:03,880 --> 05:07:10,880
I want to not forget, at the end of the notes, there is a feedback form.

2328
05:07:10,880 --> 05:07:17,160
And before you disconnect for today, please leave us feedback.

2329
05:07:17,160 --> 05:07:22,040
Tell us how it went today, tell us one thing that was particularly good, and one thing

2330
05:07:22,040 --> 05:07:28,880
that we should improve, change, remove for next time.

2331
05:07:28,880 --> 05:07:38,160
And I will use now a few more minutes to mention and discuss AI-assisted coding because it's

2332
05:07:38,160 --> 05:07:45,240
at least since for the last two years these tools are very popular.

2333
05:07:45,240 --> 05:07:47,680
I use them.

2334
05:07:47,680 --> 05:07:50,800
They come with risks.

2335
05:07:50,800 --> 05:07:59,840
I wanted to mention here. So what are the tools that I use? I use AI-assisted coding.

2336
05:08:02,000 --> 05:08:06,480
So this can either happen in the editor or I ask

2337
05:08:09,440 --> 05:08:17,920
the tool. In this case this was JGPT. I can ask it questions and then it can help me and we refine

2338
05:08:17,920 --> 05:08:20,640
the code and I can ask follow-up questions.

2339
05:08:23,120 --> 05:08:25,080
I use these in,

2340
05:08:25,080 --> 05:08:27,580
so sometimes I use them and I'm the,

2341
05:08:29,600 --> 05:08:30,440
like,

2342
05:08:31,880 --> 05:08:35,760
I use it as a kind of an assistant, an apprentice.

2343
05:08:35,760 --> 05:08:37,720
So I basically, I know the answer,

2344
05:08:37,720 --> 05:08:41,760
but I ask it to complete some task

2345
05:08:41,760 --> 05:08:45,220
or write a test for an implementation.

2346
05:08:45,220 --> 05:08:49,980
or if I have a test, I want to write the implementation for me

2347
05:08:49,980 --> 05:08:51,940
or I ask it to write the documentation.

2348
05:08:54,380 --> 05:08:57,220
Sometimes I'm the apprentice and I use it as a mentor

2349
05:08:57,220 --> 05:08:59,940
to explain a concept to me, to improve my code.

2350
05:09:00,860 --> 05:09:03,540
And sometimes it can show me a different

2351
05:09:03,540 --> 05:09:05,140
and possibly better way of implementing

2352
05:09:05,140 --> 05:09:06,820
than what I came up with.

2353
05:09:10,900 --> 05:09:13,300
So here, you know, kind of a chat format.

2354
05:09:15,220 --> 05:09:20,220
At least another way to use AI is this.

2355
05:09:22,160 --> 05:09:23,800
So this video that we see is,

2356
05:09:24,720 --> 05:09:27,200
that was me typing something in the editor

2357
05:09:27,200 --> 05:09:32,200
and AI suggesting of how it could continue

2358
05:09:32,520 --> 05:09:35,460
and then I can accept the suggestion or reject it.

2359
05:09:36,700 --> 05:09:38,500
So here I was implementing conversion

2360
05:09:38,500 --> 05:09:40,880
from Fahrenheit to Celsius.

2361
05:09:40,880 --> 05:09:45,880
And then if I like it, I press, I can kind of accept it.

2362
05:09:46,960 --> 05:09:50,200
And you can see that without much typing on my side,

2363
05:09:50,200 --> 05:09:52,400
I could come up with a pretty okay solution.

2364
05:09:56,240 --> 05:09:59,920
But I wanted to mention here that, of course,

2365
05:09:59,920 --> 05:10:04,240
these tools open up a box of questions, problems,

2366
05:10:04,240 --> 05:10:06,000
or sometimes they cost money.

2367
05:10:06,000 --> 05:10:11,000
There could be, they open up a box of legal

2368
05:10:12,120 --> 05:10:14,100
and ethical questions.

2369
05:10:14,100 --> 05:10:17,520
Definitely, there is a concern about privacy.

2370
05:10:17,520 --> 05:10:20,940
So I don't use these tools when it's about sensitive data,

2371
05:10:20,940 --> 05:10:21,880
personal data.

2372
05:10:22,820 --> 05:10:25,260
So if I need to open a file that contains

2373
05:10:25,260 --> 05:10:26,860
these kinds of sensitive information,

2374
05:10:26,860 --> 05:10:28,660
I don't open it with an editor

2375
05:10:28,660 --> 05:10:33,220
that then potentially sends information somewhere else.

2376
05:10:33,220 --> 05:10:34,500
And this information is processed

2377
05:10:34,500 --> 05:10:35,800
and I don't even know how.

2378
05:10:39,340 --> 05:10:40,740
Then there are more philosophical question.

2379
05:10:40,740 --> 05:10:43,660
I mean, will we still need to learn programming?

2380
05:10:43,660 --> 05:10:46,560
Yes, I think so, because it's still good to know the basics.

2381
05:10:46,560 --> 05:10:48,780
It's still good to know whether the answer

2382
05:10:48,780 --> 05:10:52,540
is that it's presented is reasonable or not.

2383
05:10:52,540 --> 05:10:54,860
How will it affect learning and teaching programming?

2384
05:10:54,860 --> 05:10:57,900
Are we going to learn better or slower?

2385
05:10:57,900 --> 05:11:00,660
I think these are questions for a different discussion.

2386
05:11:04,500 --> 05:11:14,740
Just having a look here at the questions and we are otherwise at the end of today's session.

2387
05:11:14,740 --> 05:11:18,700
So again, a reminder here about the feedback.

2388
05:11:18,700 --> 05:11:20,460
This is incredibly valuable for us.

2389
05:11:20,460 --> 05:11:23,180
Let us know how, how was the level, how was the speed?

2390
05:11:23,180 --> 05:11:27,320
Was it too easy, too difficult, too fast, too slow?

2391
05:11:27,320 --> 05:11:33,520
And the things that we can change already until tomorrow, we will try to.

2392
05:11:33,520 --> 05:11:37,860
maybe we can use the last few minutes to give a little outlook of what what

2393
05:11:37,860 --> 05:11:43,260
people can expect tomorrow at the third day of the workshop yeah so compared to

2394
05:11:43,260 --> 05:11:52,060
today is there any extra preparation for tomorrow and my hands are a bit full so

2395
05:11:52,060 --> 05:11:59,540
if someone can write it in the notes there yeah any particular wrap-up or

2396
05:11:59,540 --> 05:12:04,960
anything to do next. Yeah, your preparation. And this goes also to the other

2397
05:12:04,960 --> 05:12:13,880
instructors for tomorrow. Let us know what what people need to prepare. As far

2398
05:12:13,880 --> 05:12:19,340
as I know, if you can do today, tomorrow should be basically a lot like this. So

2399
05:12:19,340 --> 05:12:26,800
various topics, a little bit of intro to different things, nothing going too deep.

2400
05:12:26,800 --> 05:12:38,680
should i have a quick look of what topics we come up tomorrow and since i don't remember

2401
05:12:38,680 --> 05:12:42,320
all of them and i want you to know where you can find this information if i scroll up to

2402
05:12:42,320 --> 05:12:55,040
the top of the page here is the program and tomorrow we will have we will talk about libraries

2403
05:12:55,040 --> 05:12:57,400
how to choose libraries, when to decide,

2404
05:12:57,400 --> 05:13:00,640
how to decide between importing a library

2405
05:13:00,640 --> 05:13:02,180
or implementing it yourself.

2406
05:13:04,400 --> 05:13:07,280
Super important topic about how to manage dependencies

2407
05:13:09,540 --> 05:13:13,580
in Python, but this topic goes also beyond just Python.

2408
05:13:14,480 --> 05:13:17,640
So there we will talk about Conda environments,

2409
05:13:17,640 --> 05:13:21,320
virtual environments, environment.yaml, requirements.txt.

2410
05:13:21,320 --> 05:13:28,660
And then we have a longer session about parallel programming in Python. Yes it's

2411
05:13:28,660 --> 05:13:36,540
possible. So different techniques on how to do it and then how to package Python.

2412
05:13:36,540 --> 05:13:40,740
So this is when you want to create a Python package that other people can

2413
05:13:40,740 --> 05:13:48,500
conda install or pip install. And we will conclude with an outro. And these are all

2414
05:13:48,500 --> 05:13:56,260
all the really good things. Some are semi-important to scientists, some are sort of tangential,

2415
05:13:56,260 --> 05:14:06,900
but good things to know about. So, yeah. But yeah, if you like today, you'll probably also

2416
05:14:06,900 --> 05:14:07,900
like tomorrow.

2417
05:14:07,900 --> 05:14:15,820
Really looking forward. Thanks, everybody, for all the questions and for being here with

2418
05:14:15,820 --> 05:14:22,540
us thanks to [name] for the 40 sessions thanks to all the instructors but also

2419
05:14:22,540 --> 05:14:28,100
local helpers who are not visible here but really make this happen behind the

2420
05:14:28,100 --> 05:14:37,860
scenes and do a lot of local help yes okay back to the studio yeah okay so I'm

2421
05:14:37,860 --> 05:14:45,460
sharing the notes here, I guess. If there's nothing else to say we should

2422
05:14:45,460 --> 05:14:48,980
call it good, right?

2423
05:14:49,620 --> 05:14:55,780
Yeah, looking forward to tomorrow. Sounds good. Thanks everybody. See you next time.

2424
05:14:55,780 --> 05:14:59,420
See you then. Bye.

2425
05:15:07,860 --> 05:15:09,920
you

2426
05:15:37,860 --> 05:15:39,920
you

2427
05:16:07,860 --> 05:16:09,920
you

2428
05:16:37,860 --> 05:16:39,920
you

